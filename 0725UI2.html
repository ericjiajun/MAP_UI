<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OSM地图编辑器 - 增强3D版本</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 5px;
            background-color: #f0f0f0;
        }
        
        .main-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding: 5px;
        }
        
        .toolbar-container {
            margin-bottom: 5px;
        }
        
        .toolbar {
            display: flex;
            gap: 5px;
            margin-bottom: 2px;
            flex-wrap: wrap;
        }
        
        .toolbar-group {
            border: 1px solid #ccc;
            border-radius: 3px;
            padding: 2px 5px;
            background-color: white;
            display: flex;
            align-items: center;
            gap: 3px;
        }
        
        .toolbar-group label {
            font-size: 12px;
            font-weight: bold;
            margin-right: 5px;
        }
        
        .toolbar-group button {
            padding: 2px 8px;
            font-size: 12px;
            min-width: 60px;
        }
        
        .toolbar-group select {
            padding: 2px 5px;
            font-size: 12px;
            min-width: 80px;
        }
        
        .toolbar-group input[type="checkbox"] {
            margin-right: 3px;
        }
        
        .toolbar-group input[type="range"] {
            width: 80px;
        }
        
        .content-container {
            display: flex;
            flex: 1;
            gap: 5px;
        }
        
        .canvas-container {
            flex: 1;
            border: 1px solid #ccc;
            position: relative;
            overflow: hidden;
        }
        
        canvas {
            display: block;
            cursor: crosshair;
        }
        
        .properties-panel {
            width: 280px;
            border: 1px solid #ccc;
            border-radius: 3px;
            background-color: white;
            padding: 5px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .panel-section {
            border: 1px solid #ccc;
            border-radius: 3px;
            padding: 8px;
        }
        
        .panel-section h3 {
            margin: 0 0 5px 0;
            font-size: 14px;
            font-weight: bold;
            color: #333;
        }
        
        .status-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 5px;
            font-size: 12px;
        }
        
        .status-label {
            font-weight: bold;
        }
        
        .button-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
        }
        
        .info-text {
            height: 120px;
            border: 1px solid #ccc;
            padding: 5px;
            font-size: 12px;
            font-family: monospace;
            overflow-y: auto;
            resize: vertical;
        }
        
        .view-info {
            font-size: 12px;
            text-align: center;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }
        
        .dialog {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border: 2px solid #333;
            border-radius: 5px;
            padding: 20px;
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
        }
        
        .dialog-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 999;
        }
        
        .dialog h3 {
            margin: 0 0 15px 0;
            font-size: 16px;
        }
        
        .dialog-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 15px;
        }
        
        .form-row {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .form-row label {
            min-width: 80px;
        }
        
        .form-row input, .form-row select {
            flex: 1;
            padding: 3px;
        }
        
        .tag-table {
            width: 100%;
            border-collapse: collapse;
            margin: 10px 0;
        }
        
        .tag-table th, .tag-table td {
            border: 1px solid #ccc;
            padding: 5px;
            text-align: left;
        }
        
        .tag-table th {
            background-color: #f0f0f0;
        }
        
        .tag-row {
            cursor: pointer;
        }
        
        .tag-row:hover {
            background-color: #f0f0f0;
        }
        
        .tag-row.selected {
            background-color: #e0e0e0;
        }
        
        button {
            padding: 5px 10px;
            border: 1px solid #ccc;
            border-radius: 3px;
            background-color: white;
            cursor: pointer;
        }
        
        button:hover {
            background-color: #f0f0f0;
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .hidden {
            display: none;
        }
        
        .measure-info {
            font-weight: bold;
            color: blue;
        }
        
        .threed-controls {
            background-color: #f8f8f8;
        }
        
        .range-input {
            width: 60px;
        }
        
        .range-label {
            font-size: 10px;
            min-width: 30px;
        }
        
        .color-preview {
            width: 20px;
            height: 20px;
            border: 1px solid #000;
            cursor: pointer;
            display: inline-block;
            margin-left: 5px;
        }
    </style>
</head>
<body>
    <div class="main-container">
        <!-- 工具栏 -->
        <div class="toolbar-container">
            <!-- 第一行工具栏 -->
            <div class="toolbar">
                <div class="toolbar-group">
                    <label>文件</label>
                    <button onclick="editor.importOSM()">导入</button>
                    <button onclick="editor.exportOSM()">导出</button>
                    <button onclick="editor.clearData()">清除</button>
                </div>
                
                <div class="toolbar-group">
                    <label>编辑</label>
                    <button id="undoBtn" onclick="editor.undo()" disabled>撤销</button>
                    <button id="redoBtn" onclick="editor.redo()" disabled>重做</button>
                </div>
                
                <div class="toolbar-group">
                    <label>编辑模式</label>
                    <select id="modeSelect" onchange="editor.onModeChange()">
                        <option value="select">选择</option>
                        <option value="add_node">添加节点</option>
                        <option value="add_way">添加路径</option>
                        <option value="add_polygon">添加多边形</option>
                        <option value="box_select">框选</option>
                        <option value="measure">测量</option>
                    </select>
                </div>
                
                <div class="toolbar-group">
                    <label>选择</label>
                    <button onclick="editor.selectAllPolygons()">全选</button>
                    <button onclick="editor.clearSelection()">清选</button>
                </div>
                
                <div class="toolbar-group">
                    <label>视图控制</label>
                    <button onclick="editor.resetView()">重置</button>
                    <button onclick="editor.fitToWindow()">适应</button>
                    <button onclick="editor.rotateView(-15)">↺</button>
                    <button onclick="editor.rotateView(15)">↻</button>
                </div>
            </div>
            
            <!-- 第二行工具栏 -->
            <div class="toolbar">
                <div class="toolbar-group">
                    <label>坐标系统</label>
                    <select id="coordSelect" onchange="editor.onCoordSystemChange()">
                        <option value="geographic">经纬度</option>
                        <option value="scene">场景坐标</option>
                    </select>
                    <button onclick="editor.setSceneOrigin()">设原点</button>
                    <button onclick="editor.useCurrentCenterAsOrigin()">用中心</button>
                </div>
                
                <div class="toolbar-group">
                    <label>显示模式</label>
                    <select id="renderSelect" onchange="editor.onRenderModeChange()">
                        <option value="geometry">几何</option>
                        <option value="rendered">渲染</option>
                        <option value="both">两者</option>
                        <option value="3d">3D视图</option>
                    </select>
                </div>
                
                <div class="toolbar-group">
                    <label>显示选项</label>
                    <input type="checkbox" id="labelsCheck" onchange="editor.toggleLabels()" checked>
                    <label for="labelsCheck">标签</label>
                    <input type="checkbox" id="gridCheck" onchange="editor.toggleGrid()" checked>
                    <label for="gridCheck">网格</label>
                    <input type="checkbox" id="compassCheck" onchange="editor.toggleCompass()" checked>
                    <label for="compassCheck">指南针</label>
                </div>
                
                <div class="toolbar-group">
                    <label>3D显示</label>
                    <input type="checkbox" id="show3DLabelsCheck" onchange="editor.toggle3DLabels()" checked>
                    <label for="show3DLabelsCheck">3D标签</label>
                    <input type="checkbox" id="showLandscapeCheck" onchange="editor.toggleLandscape()" checked>
                    <label for="showLandscapeCheck">地貌</label>
                </div>
                
                <div class="toolbar-group">
                    <label>工具</label>
                    <button onclick="editor.showGridControlPanel()">网格面板</button>
                    <button onclick="editor.showMapCalibration()">地图校正</button>
                </div>
                
                <div class="toolbar-group">
                    <label>测量</label>
                    <span id="measureLabel" class="measure-info">距离: 0m</span>
                    <button onclick="editor.clearMeasurement()">清除</button>
                </div>
            </div>
            
            <!-- 第三行工具栏 - 3D控制 -->
            <div class="toolbar" id="threedToolbar" style="display: none;">
                <div class="toolbar-group threed-controls">
                    <label>3D视角</label>
                    <span class="range-label">俯视:</span>
                    <input type="range" id="viewAngleSlider" min="0" max="90" value="45" class="range-input" onchange="editor.update3DView()">
                    <span class="range-label">旋转:</span>
                    <input type="range" id="rotationAngleSlider" min="0" max="360" value="0" class="range-input" onchange="editor.update3DView()">
                    <span class="range-label">高度:</span>
                    <input type="range" id="heightScaleSlider" min="0.1" max="5" step="0.1" value="1" class="range-input" onchange="editor.update3DView()">
                </div>
                
                <div class="toolbar-group">
                    <label>建筑控制</label>
                    <button onclick="editor.editBuildingHeight()">编辑高度</button>
                    <button onclick="editor.editBuildingColor()">编辑颜色</button>
                    <button onclick="editor.randomizeBuildingHeights()">随机高度</button>
                    <button onclick="editor.clearBuildingHeights()">清除高度</button>
                </div>
                
                <div class="toolbar-group">
                    <label>3D设置</label>
                    <button onclick="editor.show3DSettings()">高级设置</button>
                    <button onclick="editor.resetCameraView()">重置视角</button>
                </div>
            </div>
        </div>
        
        <!-- 主内容区域 -->
        <div class="content-container">
            <!-- 画布区域 -->
            <div class="canvas-container">
                <canvas id="mapCanvas"></canvas>
            </div>
            
            <!-- 属性面板 -->
            <div class="properties-panel">
                <div class="panel-section">
                    <h3>状态信息</h3>
                    <div class="status-grid">
                        <span class="status-label">鼠标:</span>
                        <span id="coordLabel">X: 0, Y: 0</span>
                        <span class="status-label">比例:</span>
                        <span id="scaleLabel">1:100000</span>
                        <span class="status-label">创建:</span>
                        <span id="createStatusLabel" style="color: blue;">无</span>
                        <span class="status-label">网格:</span>
                        <span id="gridStatusLabel" style="color: green;">显示</span>
                        <span class="status-label">选择:</span>
                        <span id="multiselectLabel" style="color: orange;">未选择</span>
                    </div>
                </div>
                
                <div class="panel-section">
                    <h3>对象操作</h3>
                    <div class="button-grid">
                        <button onclick="editor.editTags()">编辑标签</button>
                        <button onclick="editor.deleteSelected()">删除对象</button>
                    </div>
                </div>
                
                <div class="panel-section">
                    <h3>对象信息</h3>
                    <div id="infoText" class="info-text"></div>
                </div>
                
                <div class="panel-section">
                    <h3>视图信息</h3>
                    <div id="viewLabel" class="view-info">缩放: 1.0<br>旋转: 0°</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 命令基类
        class Command {
            execute() {}
            undo() {}
        }

        // 移动节点命令
        class MoveNodeCommand extends Command {
            constructor(editor, nodeId, oldPos, newPos) {
                super();
                this.editor = editor;
                this.nodeId = nodeId;
                this.oldPos = oldPos;
                this.newPos = newPos;
            }

            execute() {
                if (this.editor.nodes.has(this.nodeId)) {
                    const node = this.editor.nodes.get(this.nodeId);
                    node.lon = this.newPos[0];
                    node.lat = this.newPos[1];
                }
            }

            undo() {
                if (this.editor.nodes.has(this.nodeId)) {
                    const node = this.editor.nodes.get(this.nodeId);
                    node.lon = this.oldPos[0];
                    node.lat = this.oldPos[1];
                }
            }
        }

        // 删除对象命令
        class DeleteObjectCommand extends Command {
            constructor(editor, objType, objId, objData, affectedWays = null) {
                super();
                this.editor = editor;
                this.objType = objType;
                this.objId = objId;
                this.objData = structuredClone(objData);
                this.affectedWays = affectedWays ? structuredClone(affectedWays) : {};
            }

            execute() {
                if (this.objType === 'node') {
                    this.editor.nodes.delete(this.objId);
                    for (const wayId of Object.keys(this.affectedWays)) {
                        this.editor.ways.delete(parseInt(wayId));
                    }
                } else if (this.objType === 'way') {
                    this.editor.ways.delete(this.objId);
                }
            }

            undo() {
                if (this.objType === 'node') {
                    this.editor.nodes.set(this.objId, structuredClone(this.objData));
                    for (const [wayId, wayData] of Object.entries(this.affectedWays)) {
                        this.editor.ways.set(parseInt(wayId), structuredClone(wayData));
                    }
                } else if (this.objType === 'way') {
                    this.editor.ways.set(this.objId, structuredClone(this.objData));
                }
            }
        }

        // 添加对象命令
        class AddObjectCommand extends Command {
            constructor(editor, objType, objId, objData) {
                super();
                this.editor = editor;
                this.objType = objType;
                this.objId = objId;
                this.objData = structuredClone(objData);
            }

            execute() {
                if (this.objType === 'node') {
                    this.editor.nodes.set(this.objId, structuredClone(this.objData));
                } else if (this.objType === 'way') {
                    this.editor.ways.set(this.objId, structuredClone(this.objData));
                }
            }

            undo() {
                if (this.objType === 'node') {
                    this.editor.nodes.delete(this.objId);
                } else if (this.objType === 'way') {
                    this.editor.ways.delete(this.objId);
                }
            }
        }

        // 修改标签命令
        class ModifyTagsCommand extends Command {
            constructor(editor, objType, objId, oldTags, newTags) {
                super();
                this.editor = editor;
                this.objType = objType;
                this.objId = objId;
                this.oldTags = structuredClone(oldTags);
                this.newTags = structuredClone(newTags);
            }

            execute() {
                if (this.objType === 'node' && this.editor.nodes.has(this.objId)) {
                    this.editor.nodes.get(this.objId).tags = structuredClone(this.newTags);
                } else if (this.objType === 'way' && this.editor.ways.has(this.objId)) {
                    this.editor.ways.get(this.objId).tags = structuredClone(this.newTags);
                }
            }

            undo() {
                if (this.objType === 'node' && this.editor.nodes.has(this.objId)) {
                    this.editor.nodes.get(this.objId).tags = structuredClone(this.oldTags);
                } else if (this.objType === 'way' && this.editor.ways.has(this.objId)) {
                    this.editor.ways.get(this.objId).tags = structuredClone(this.oldTags);
                }
            }
        }

        // 网格设置类
        class GridSettings {
            constructor() {
                this.originX = 0.0;
                this.originY = 0.0;
                this.gridSizeMeters = 100;
                this.showGrid = true;
                this.gridColor = 'lightgray';
                this.axisColor = 'red';
                this.showCoordinates = true;
                this.snapToGrid = false;
            }
        }

        // 坐标系统类
        class CoordinateSystem {
            constructor() {
                this.coordType = "geographic";
                this.sceneOriginLon = 0.0;
                this.sceneOriginLat = 0.0;
                this.metersPerDegreeLat = 111320;
            }

            geographicToScene(lon, lat) {
                const metersPerDegreeLon = this.metersPerDegreeLat * Math.cos(lat * Math.PI / 180);
                const x = (lon - this.sceneOriginLon) * metersPerDegreeLon;
                const y = (lat - this.sceneOriginLat) * this.metersPerDegreeLat;
                return [x, y];
            }

            sceneToGeographic(x, y) {
                const lat = this.sceneOriginLat + y / this.metersPerDegreeLat;
                const metersPerDegreeLon = this.metersPerDegreeLat * Math.cos(lat * Math.PI / 180);
                const lon = this.sceneOriginLon + x / metersPerDegreeLon;
                return [lon, lat];
            }
        }

        // 3D设置类
        class ThreeDSettings {
            constructor() {
                this.viewAngle = 45;           // 俯视角度 0-90度
                this.rotationAngle = 0;        // 水平旋转角度 0-360度
                this.heightScale = 1.0;        // 高度缩放比例
                this.lightAngle = 135;         // 光照角度
                this.shadowIntensity = 0.3;    // 阴影强度
                this.defaultHeight = 10;       // 默认建筑高度(米)
                this.wallColorIntensity = 0.8; // 墙面颜色强度
                this.show3DLabels = true;      // 显示3D标签
                this.showLandscape = true;     // 显示地貌
                this.defaultBuildingColor = '#F0F0F0'; // 默认建筑颜色
            }
        }

        // 主编辑器类
        class OSMEditor {
            constructor() {
                this.canvas = document.getElementById('mapCanvas');
                this.ctx = this.canvas.getContext('2d');
                
                // 数据存储
                this.nodes = new Map();
                this.ways = new Map();
                this.relations = new Map();
                
                // 撤销/重做系统
                this.undoStack = [];
                this.redoStack = [];
                this.maxUndoLevels = 50;
                
                // 视图参数
                this.scale = 100000;
                this.centerX = 0;
                this.centerY = 0;
                this.rotation = 0;
                
                // 交互状态
                this.selectedNode = null;
                this.selectedWay = null;
                this.selectedWays = new Set();
                this.dragStart = null;
                this.mode = "select";
                this.creatingWay = [];
                this.draggingNode = false;
                this.nodeStartPos = null;
                
                // 框选功能
                this.boxSelecting = false;
                this.boxStart = null;
                this.boxCurrent = null;
                
                // 距离测量功能
                this.measuring = false;
                this.measurePoints = [];
                this.measureDistances = [];
                
                // 渲染模式
                this.renderMode = "geometry";
                this.showLabels = true;
                
                // 网格设置
                this.gridSettings = new GridSettings();
                
                // 坐标系统
                this.coordSystem = new CoordinateSystem();
                
                // 3D设置
                this.threeDSettings = new ThreeDSettings();
                
                // 指南针参数
                this.compassSize = 80;
                
                // 地理坐标转换常数
                this.metersPerDegreeLat = 111320;
                
                this.setupCanvas();
                this.bindEvents();
                this.updateUndoRedoButtons();
                this.redraw();
            }

            setupCanvas() {
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }

            resizeCanvas() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
                this.redraw();
            }

            bindEvents() {
                // 鼠标事件
                this.canvas.addEventListener('mousedown', (e) => this.onClick(e));
                this.canvas.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    this.onRightClick(e);
                });
                this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.onRelease(e));
                this.canvas.addEventListener('wheel', (e) => this.onScroll(e));
                this.canvas.addEventListener('dblclick', (e) => this.onDoubleClick(e));
                
                // 键盘事件
                document.addEventListener('keydown', (e) => this.onKey(e));
                
                // 画布获得焦点
                this.canvas.tabIndex = 0;
                this.canvas.focus();
            }

            executeCommand(command) {
                command.execute();
                this.undoStack.push(command);
                this.redoStack = [];
                
                if (this.undoStack.length > this.maxUndoLevels) {
                    this.undoStack.shift();
                }
                
                this.updateUndoRedoButtons();
            }

            undo() {
                if (this.undoStack.length > 0) {
                    const command = this.undoStack.pop();
                    command.undo();
                    this.redoStack.push(command);
                    this.updateUndoRedoButtons();
                    this.redraw();
                    this.updateSelectionInfo();
                }
            }

            redo() {
                if (this.redoStack.length > 0) {
                    const command = this.redoStack.pop();
                    command.execute();
                    this.undoStack.push(command);
                    this.updateUndoRedoButtons();
                    this.redraw();
                    this.updateSelectionInfo();
                }
            }

            updateUndoRedoButtons() {
                document.getElementById('undoBtn').disabled = this.undoStack.length === 0;
                document.getElementById('redoBtn').disabled = this.redoStack.length === 0;
            }

            onModeChange() {
                this.mode = document.getElementById('modeSelect').value;
                const cursors = {
                    "select": "default",
                    "add_node": "crosshair",
                    "add_way": "crosshair",
                    "add_polygon": "crosshair",
                    "box_select": "crosshair",
                    "measure": "crosshair"
                };
                this.canvas.style.cursor = cursors[this.mode] || "default";
                
                this.creatingWay = [];
                this.updateCreateStatus();
                
                if (this.mode !== "measure" && this.measurePoints.length > 0) {
                    this.clearMeasurement();
                }
            }

            onRenderModeChange() {
                this.renderMode = document.getElementById('renderSelect').value;
                
                const threedToolbar = document.getElementById('threedToolbar');
                if (this.renderMode === '3d') {
                    threedToolbar.style.display = 'flex';
                    this.update3DView();
                } else {
                    threedToolbar.style.display = 'none';
                }
                
                this.redraw();
            }

            onCoordSystemChange() {
                this.coordSystem.coordType = document.getElementById('coordSelect').value;
                this.redraw();
            }

            toggleLabels() {
                this.showLabels = document.getElementById('labelsCheck').checked;
                this.redraw();
            }

            toggleGrid() {
                this.gridSettings.showGrid = document.getElementById('gridCheck').checked;
                this.updateGridStatus();
                this.redraw();
            }

            toggleCompass() {
                this.redraw();
            }

            toggle3DLabels() {
                this.threeDSettings.show3DLabels = document.getElementById('show3DLabelsCheck').checked;
                this.redraw();
            }

            toggleLandscape() {
                this.threeDSettings.showLandscape = document.getElementById('showLandscapeCheck').checked;
                this.redraw();
            }

            // 3D功能方法
            update3DView() {
                if (this.renderMode === '3d') {
                    this.threeDSettings.viewAngle = parseFloat(document.getElementById('viewAngleSlider').value);
                    this.threeDSettings.rotationAngle = parseFloat(document.getElementById('rotationAngleSlider').value);
                    this.threeDSettings.heightScale = parseFloat(document.getElementById('heightScaleSlider').value);
                    this.redraw();
                }
            }

            resetCameraView() {
                document.getElementById('viewAngleSlider').value = 45;
                document.getElementById('rotationAngleSlider').value = 0;
                document.getElementById('heightScaleSlider').value = 1;
                this.update3DView();
            }

            getBuildingHeight(tags) {
                if (tags.height) {
                    const height = parseFloat(tags.height);
                    if (!isNaN(height)) return height;
                }
                
                if (tags.levels || tags['building:levels']) {
                    const levels = parseFloat(tags.levels || tags['building:levels']);
                    if (!isNaN(levels)) return levels * 3;
                }
                
                if (tags['building:height']) {
                    const height = parseFloat(tags['building:height']);
                    if (!isNaN(height)) return height;
                }
                
                const buildingType = tags.building;
                const defaultHeights = {
                    'house': 6,
                    'residential': 15,
                    'commercial': 20,
                    'retail': 8,
                    'office': 25,
                    'industrial': 12,
                    'school': 10,
                    'university': 15,
                    'hospital': 18,
                    'apartment': 30,
                    'hotel': 25
                };
                
                return defaultHeights[buildingType] || this.threeDSettings.defaultHeight;
            }

            getBuildingColor(tags) {
                // 检查建筑物颜色标签
                let color = null;
                
                if (tags['building:colour']) {
                    color = tags['building:colour'];
                } else if (tags['building:color']) {
                    color = tags['building:color'];
                } else if (tags.colour) {
                    color = tags.colour;
                } else if (tags.color) {
                    color = tags.color;
                }
                
                // 如果找到了颜色，确保格式正确
                if (color) {
                    return this.ensureHexColor(color);
                }
                
                // 如果没有找到颜色，返回默认颜色
                return this.threeDSettings.defaultBuildingColor;
            }

            // 3D渲染建筑物
            drawBuilding3D(points, tags, wayId) {
                if (points.length < 3) return;
                
                const height = this.getBuildingHeight(tags);
                const scaledHeight = height * this.threeDSettings.heightScale;
                const buildingColor = this.getBuildingColor(tags);
                
                // 考虑旋转和俯视角度
                const viewAngleRad = this.threeDSettings.viewAngle * Math.PI / 180;
                const rotationRad = this.threeDSettings.rotationAngle * Math.PI / 180;
                const heightPixels = scaledHeight * this.scale / this.metersPerDegreeLat;
                
                const offsetX = heightPixels * Math.cos(viewAngleRad) * Math.cos(rotationRad) * 0.6;
                const offsetY = -heightPixels * Math.sin(viewAngleRad) * 0.6 + heightPixels * Math.cos(viewAngleRad) * Math.sin(rotationRad) * 0.3;
                
                const topPoints = points.map(([x, y]) => [x + offsetX, y + offsetY]);
                
                const isSelected = this.selectedWays.has(wayId);
                
                // 绘制建筑物阴影
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                this.ctx.beginPath();
                this.ctx.moveTo(points[0][0], points[0][1]);
                for (let i = 1; i < points.length; i++) {
                    this.ctx.lineTo(points[i][0], points[i][1]);
                }
                this.ctx.closePath();
                this.ctx.fill();
                
                // 绘制建筑物侧面
                for (let i = 0; i < points.length - 1; i++) {
                    const [x1, y1] = points[i];
                    const [x2, y2] = points[i + 1];
                    const [tx1, ty1] = topPoints[i];
                    const [tx2, ty2] = topPoints[i + 1];
                    
                    // 计算光照
                    const wallNormalX = -(y2 - y1);
                    const wallNormalY = x2 - x1;
                    const wallLength = Math.sqrt(wallNormalX * wallNormalX + wallNormalY * wallNormalY);
                    const normalX = wallNormalX / wallLength;
                    const normalY = wallNormalY / wallLength;
                    
                    const lightAngleRad = this.threeDSettings.lightAngle * Math.PI / 180;
                    const lightX = Math.cos(lightAngleRad);
                    const lightY = Math.sin(lightAngleRad);
                    const lightIntensity = Math.max(0.3, Math.abs(normalX * lightX + normalY * lightY));
                    
                    let wallColor = buildingColor;
                    if (isSelected) {
                        wallColor = '#FFFF00';
                    } else {
                        // 应用光照效果
                        const rgb = this.hexToRgb(buildingColor);
                        if (rgb) {
                            const r = Math.round(rgb.r * lightIntensity * this.threeDSettings.wallColorIntensity);
                            const g = Math.round(rgb.g * lightIntensity * this.threeDSettings.wallColorIntensity);
                            const b = Math.round(rgb.b * lightIntensity * this.threeDSettings.wallColorIntensity);
                            wallColor = `rgb(${r}, ${g}, ${b})`;
                        } else {
                            // 如果颜色转换失败，使用原色但降低亮度
                            wallColor = buildingColor;
                        }
                    }
                    
                    // 绘制墙面
                    this.ctx.fillStyle = wallColor;
                    this.ctx.strokeStyle = '#000000';
                    this.ctx.lineWidth = 1;
                    this.ctx.beginPath();
                    this.ctx.moveTo(x1, y1);
                    this.ctx.lineTo(x2, y2);
                    this.ctx.lineTo(tx2, ty2);
                    this.ctx.lineTo(tx1, ty1);
                    this.ctx.closePath();
                    this.ctx.fill();
                    this.ctx.stroke();
                }
                
                // 绘制建筑物顶面
                let topColor = buildingColor;
                if (isSelected) {
                    topColor = '#FFFF00';
                } else {
                    // 顶面使用较亮的颜色
                    const rgb = this.hexToRgb(buildingColor);
                    if (rgb) {
                        const r = Math.min(255, Math.round(rgb.r * 1.2));
                        const g = Math.min(255, Math.round(rgb.g * 1.2));
                        const b = Math.min(255, Math.round(rgb.b * 1.2));
                        topColor = `rgb(${r}, ${g}, ${b})`;
                    } else {
                        // 如果颜色转换失败，直接使用原色
                        topColor = buildingColor;
                    }
                }
                
                this.ctx.fillStyle = topColor;
                this.ctx.strokeStyle = '#000000';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(topPoints[0][0], topPoints[0][1]);
                for (let i = 1; i < topPoints.length; i++) {
                    this.ctx.lineTo(topPoints[i][0], topPoints[i][1]);
                }
                this.ctx.closePath();
                this.ctx.fill();
                this.ctx.stroke();
                
                // 绘制高度标签
                if (this.threeDSettings.show3DLabels) {
                    const centerX = topPoints.reduce((sum, p) => sum + p[0], 0) / topPoints.length;
                    const centerY = topPoints.reduce((sum, p) => sum + p[1], 0) / topPoints.length;
                    
                    const heightText = height < 1000 ? `${height.toFixed(1)}m` : `${(height/1000).toFixed(2)}km`;
                    
                    this.ctx.fillStyle = 'white';
                    this.ctx.strokeStyle = 'black';
                    this.ctx.lineWidth = 1;
                    this.ctx.font = 'bold 9px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    
                    const textWidth = this.ctx.measureText(heightText).width;
                    this.ctx.fillRect(centerX - textWidth/2 - 2, centerY - 6, textWidth + 4, 12);
                    this.ctx.strokeRect(centerX - textWidth/2 - 2, centerY - 6, textWidth + 4, 12);
                    
                    this.ctx.fillStyle = 'black';
                    this.ctx.fillText(heightText, centerX, centerY);
                }
            }

            // 3D渲染其他几何图形
            drawWay3D(points, tags, isClosed, isSelected, isMultiSelected) {
                if (points.length < 2) return;
                
                // 3D高度偏移（比建筑物低很多）
                const viewAngleRad = this.threeDSettings.viewAngle * Math.PI / 180;
                const rotationRad = this.threeDSettings.rotationAngle * Math.PI / 180;
                const baseHeight = 2; // 基础高度2米
                const heightPixels = baseHeight * this.scale / this.metersPerDegreeLat;
                
                const offsetX = heightPixels * Math.cos(viewAngleRad) * Math.cos(rotationRad) * 0.6;
                const offsetY = -heightPixels * Math.sin(viewAngleRad) * 0.6 + heightPixels * Math.cos(viewAngleRad) * Math.sin(rotationRad) * 0.3;
                
                const style = this.getWayStyle(tags);
                const color = isSelected ? 'red' : (isMultiSelected ? 'yellow' : style.fill);
                const width = (isSelected || isMultiSelected) ? style.width + 2 : style.width;
                
                if (isClosed && points.length >= 3) {
                    // 绘制底面阴影
                    this.ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                    this.ctx.beginPath();
                    this.ctx.moveTo(points[0][0], points[0][1]);
                    for (let i = 1; i < points.length; i++) {
                        this.ctx.lineTo(points[i][0], points[i][1]);
                    }
                    this.ctx.closePath();
                    this.ctx.fill();
                    
                    // 绘制侧面
                    for (let i = 0; i < points.length - 1; i++) {
                        const [x1, y1] = points[i];
                        const [x2, y2] = points[i + 1];
                        const [tx1, ty1] = [x1 + offsetX, y1 + offsetY];
                        const [tx2, ty2] = [x2 + offsetX, y2 + offsetY];
                        
                        this.ctx.fillStyle = color;
                        this.ctx.strokeStyle = 'black';
                        this.ctx.lineWidth = 1;
                        this.ctx.beginPath();
                        this.ctx.moveTo(x1, y1);
                        this.ctx.lineTo(x2, y2);
                        this.ctx.lineTo(tx2, ty2);
                        this.ctx.lineTo(tx1, ty1);
                        this.ctx.closePath();
                        this.ctx.fill();
                        this.ctx.stroke();
                    }
                    
                    // 绘制顶面
                    this.ctx.fillStyle = color;
                    this.ctx.strokeStyle = 'black';
                    this.ctx.lineWidth = width;
                    this.ctx.beginPath();
                    this.ctx.moveTo(points[0][0] + offsetX, points[0][1] + offsetY);
                    for (let i = 1; i < points.length; i++) {
                        this.ctx.lineTo(points[i][0] + offsetX, points[i][1] + offsetY);
                    }
                    this.ctx.closePath();
                    this.ctx.fill();
                    this.ctx.stroke();
                } else {
                    // 绘制道路的3D效果
                    // 底部阴影线
                    this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                    this.ctx.lineWidth = width + 2;
                    this.ctx.beginPath();
                    this.ctx.moveTo(points[0][0], points[0][1]);
                    for (let i = 1; i < points.length; i++) {
                        this.ctx.lineTo(points[i][0], points[i][1]);
                    }
                    this.ctx.stroke();
                    
                    // 顶部线条
                    this.ctx.strokeStyle = color;
                    this.ctx.lineWidth = width;
                    this.ctx.beginPath();
                    this.ctx.moveTo(points[0][0] + offsetX, points[0][1] + offsetY);
                    for (let i = 1; i < points.length; i++) {
                        this.ctx.lineTo(points[i][0] + offsetX, points[i][1] + offsetY);
                    }
                    this.ctx.stroke();
                    
                    // 连接线（侧面效果）
                    for (let i = 0; i < points.length; i++) {
                        this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
                        this.ctx.lineWidth = 1;
                        this.ctx.beginPath();
                        this.ctx.moveTo(points[i][0], points[i][1]);
                        this.ctx.lineTo(points[i][0] + offsetX, points[i][1] + offsetY);
                        this.ctx.stroke();
                    }
                }
            }

            // 3D渲染地貌（草坪、森林等）
            drawLandscape3D(points, tags, wayId) {
                if (!this.threeDSettings.showLandscape || points.length < 3) return;
                
                const landuse = tags.landuse;
                const natural = tags.natural;
                const leisure = tags.leisure;
                
                let landscapeColor = null;
                let landscapeHeight = 0.5; // 默认地貌高度
                
                if (landuse === 'grass' || leisure === 'park' || leisure === 'garden') {
                    landscapeColor = '#90EE90'; // 浅绿色草坪
                } else if (natural === 'forest' || natural === 'wood' || landuse === 'forest') {
                    landscapeColor = '#228B22'; // 森林绿
                    landscapeHeight = 8; // 森林高一些
                } else if (landuse === 'farmland' || landuse === 'meadow') {
                    landscapeColor = '#ADFF2F'; // 农田绿
                } else if (natural === 'water' || landuse === 'reservoir') {
                    landscapeColor = '#4169E1'; // 水体蓝
                    landscapeHeight = -0.5; // 水面稍低
                } else if (landuse === 'residential') {
                    landscapeColor = '#FFE4B5'; // 住宅区
                } else if (landuse === 'commercial') {
                    landscapeColor = '#DDA0DD'; // 商业区
                } else if (landuse === 'industrial') {
                    landscapeColor = '#D3D3D3'; // 工业区
                }
                
                if (!landscapeColor) return;
                
                const scaledHeight = landscapeHeight * this.threeDSettings.heightScale;
                const viewAngleRad = this.threeDSettings.viewAngle * Math.PI / 180;
                const rotationRad = this.threeDSettings.rotationAngle * Math.PI / 180;
                const heightPixels = scaledHeight * this.scale / this.metersPerDegreeLat;
                
                const offsetX = heightPixels * Math.cos(viewAngleRad) * Math.cos(rotationRad) * 0.6;
                const offsetY = -heightPixels * Math.sin(viewAngleRad) * 0.6 + heightPixels * Math.cos(viewAngleRad) * Math.sin(rotationRad) * 0.3;
                
                const topPoints = points.map(([x, y]) => [x + offsetX, y + offsetY]);
                const isSelected = this.selectedWays.has(wayId);
                
                // 绘制底面
                this.ctx.fillStyle = isSelected ? '#FFFF00' : landscapeColor;
                this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                this.ctx.lineWidth = 1;
                this.ctx.beginPath();
                this.ctx.moveTo(points[0][0], points[0][1]);
                for (let i = 1; i < points.length; i++) {
                    this.ctx.lineTo(points[i][0], points[i][1]);
                }
                this.ctx.closePath();
                this.ctx.fill();
                this.ctx.stroke();
                
                // 只有高度大于0才绘制侧面和顶面
                if (landscapeHeight > 0) {
                    // 绘制侧面
                    for (let i = 0; i < points.length - 1; i++) {
                        const [x1, y1] = points[i];
                        const [x2, y2] = points[i + 1];
                        const [tx1, ty1] = topPoints[i];
                        const [tx2, ty2] = topPoints[i + 1];
                        
                        const rgb = this.hexToRgb(landscapeColor);
                        let sideColor = landscapeColor;
                        if (rgb) {
                            const r = Math.round(rgb.r * 0.8);
                            const g = Math.round(rgb.g * 0.8);
                            const b = Math.round(rgb.b * 0.8);
                            sideColor = `rgb(${r}, ${g}, ${b})`;
                        }
                        
                        this.ctx.fillStyle = isSelected ? '#FFFF00' : sideColor;
                        this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                        this.ctx.lineWidth = 1;
                        this.ctx.beginPath();
                        this.ctx.moveTo(x1, y1);
                        this.ctx.lineTo(x2, y2);
                        this.ctx.lineTo(tx2, ty2);
                        this.ctx.lineTo(tx1, ty1);
                        this.ctx.closePath();
                        this.ctx.fill();
                        this.ctx.stroke();
                    }
                    
                    // 绘制顶面
                    const rgb = this.hexToRgb(landscapeColor);
                    let topColor = landscapeColor;
                    if (rgb) {
                        const r = Math.min(255, Math.round(rgb.r * 1.1));
                        const g = Math.min(255, Math.round(rgb.g * 1.1));
                        const b = Math.min(255, Math.round(rgb.b * 1.1));
                        topColor = `rgb(${r}, ${g}, ${b})`;
                    }
                    
                    this.ctx.fillStyle = isSelected ? '#FFFF00' : topColor;
                    this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                    this.ctx.lineWidth = 1;
                    this.ctx.beginPath();
                    this.ctx.moveTo(topPoints[0][0], topPoints[0][1]);
                    for (let i = 1; i < topPoints.length; i++) {
                        this.ctx.lineTo(topPoints[i][0], topPoints[i][1]);
                    }
                    this.ctx.closePath();
                    this.ctx.fill();
                    this.ctx.stroke();
                }
                
                // 绘制地貌标签
                if (this.threeDSettings.show3DLabels && tags.name) {
                    const centerX = topPoints.reduce((sum, p) => sum + p[0], 0) / topPoints.length;
                    const centerY = topPoints.reduce((sum, p) => sum + p[1], 0) / topPoints.length;
                    
                    this.ctx.fillStyle = 'white';
                    this.ctx.strokeStyle = 'black';
                    this.ctx.lineWidth = 1;
                    this.ctx.font = 'bold 8px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    
                    const nameLabel = this.getNameLabel(tags.name);
                    const textWidth = this.ctx.measureText(nameLabel).width;
                    this.ctx.fillRect(centerX - textWidth/2 - 2, centerY - 5, textWidth + 4, 10);
                    this.ctx.strokeRect(centerX - textWidth/2 - 2, centerY - 5, textWidth + 4, 10);
                    
                    this.ctx.fillStyle = 'black';
                    this.ctx.fillText(nameLabel, centerX, centerY);
                }
            }

            hexToRgb(hex) {
                // 确保输入是字符串
                if (!hex || typeof hex !== 'string') {
                    return null;
                }
                
                // 移除 # 符号
                hex = hex.replace('#', '');
                
                // 处理3位hex格式 (例如: abc -> aabbcc)
                if (hex.length === 3) {
                    hex = hex.split('').map(c => c + c).join('');
                }
                
                // 验证是否为有效的6位hex
                if (hex.length !== 6 || !/^[0-9A-Fa-f]{6}$/.test(hex)) {
                    console.warn('Invalid hex color:', hex);
                    return null;
                }
                
                const r = parseInt(hex.substr(0, 2), 16);
                const g = parseInt(hex.substr(2, 2), 16);
                const b = parseInt(hex.substr(4, 2), 16);
                
                return { r, g, b };
            }

            show3DSettings() {
                const dialog = this.createDialog('3D设置', 500, 500);
                
                dialog.innerHTML = `
                    <h3>3D视图设置</h3>
                    
                    <div class="form-row">
                        <label>俯视角度:</label>
                        <input type="range" id="viewAngleInput" min="0" max="90" value="${this.threeDSettings.viewAngle}" step="1">
                        <span id="viewAngleValue">${this.threeDSettings.viewAngle}°</span>
                    </div>
                    
                    <div class="form-row">
                        <label>水平旋转:</label>
                        <input type="range" id="rotationAngleInput" min="0" max="360" value="${this.threeDSettings.rotationAngle}" step="1">
                        <span id="rotationAngleValue">${this.threeDSettings.rotationAngle}°</span>
                    </div>
                    
                    <div class="form-row">
                        <label>高度缩放:</label>
                        <input type="range" id="heightScaleInput" min="0.1" max="5" value="${this.threeDSettings.heightScale}" step="0.1">
                        <span id="heightScaleValue">${this.threeDSettings.heightScale}x</span>
                    </div>
                    
                    <div class="form-row">
                        <label>光照角度:</label>
                        <input type="range" id="lightAngleInput" min="0" max="360" value="${this.threeDSettings.lightAngle}" step="15">
                        <span id="lightAngleValue">${this.threeDSettings.lightAngle}°</span>
                    </div>
                    
                    <div class="form-row">
                        <label>阴影强度:</label>
                        <input type="range" id="shadowIntensityInput" min="0" max="1" value="${this.threeDSettings.shadowIntensity}" step="0.1">
                        <span id="shadowIntensityValue">${this.threeDSettings.shadowIntensity}</span>
                    </div>
                    
                    <div class="form-row">
                        <label>默认高度:</label>
                        <input type="number" id="defaultHeightInput" value="${this.threeDSettings.defaultHeight}" min="1" max="1000">
                        <span>米</span>
                    </div>
                    
                    <div class="form-row">
                        <label>墙面颜色强度:</label>
                        <input type="range" id="wallColorIntensityInput" min="0.3" max="1" value="${this.threeDSettings.wallColorIntensity}" step="0.1">
                        <span id="wallColorIntensityValue">${this.threeDSettings.wallColorIntensity}</span>
                    </div>
                    
                    <div class="form-row">
                        <label>默认建筑颜色:</label>
                        <input type="color" id="defaultBuildingColorInput" value="${this.threeDSettings.defaultBuildingColor}">
                        <div class="color-preview" style="background-color: ${this.threeDSettings.defaultBuildingColor}"></div>
                    </div>
                    
                    <div class="form-row">
                        <input type="checkbox" id="show3DLabelsInput" ${this.threeDSettings.show3DLabels ? 'checked' : ''}>
                        <label for="show3DLabelsInput">显示3D标签</label>
                    </div>
                    
                    <div class="form-row">
                        <input type="checkbox" id="showLandscapeInput" ${this.threeDSettings.showLandscape ? 'checked' : ''}>
                        <label for="showLandscapeInput">显示地貌</label>
                    </div>
                    
                    <div class="dialog-buttons">
                        <button onclick="editor.apply3DSettings()">确定</button>
                        <button onclick="editor.reset3DSettings()">重置</button>
                        <button onclick="editor.closeDialog()">取消</button>
                    </div>
                `;
                
                // 绑定滑块更新事件
                const sliders = [
                    'viewAngleInput', 'rotationAngleInput', 'heightScaleInput', 'lightAngleInput', 
                    'shadowIntensityInput', 'wallColorIntensityInput'
                ];
                
                sliders.forEach(sliderId => {
                    const slider = document.getElementById(sliderId);
                    const valueSpan = document.getElementById(sliderId.replace('Input', 'Value'));
                    
                    slider.addEventListener('input', () => {
                        let value = parseFloat(slider.value);
                        let displayValue = value;
                        
                        if (sliderId.includes('Angle')) {
                            displayValue = value + '°';
                        } else if (sliderId === 'heightScaleInput') {
                            displayValue = value + 'x';
                        }
                        
                        valueSpan.textContent = displayValue;
                        this.preview3DSettings();
                    });
                });
                
                // 颜色选择器事件
                document.getElementById('defaultBuildingColorInput').addEventListener('change', () => {
                    this.preview3DSettings();
                });
                
                // 复选框事件
                ['show3DLabelsInput', 'showLandscapeInput'].forEach(checkboxId => {
                    document.getElementById(checkboxId).addEventListener('change', () => {
                        this.preview3DSettings();
                    });
                });
            }

            preview3DSettings() {
                this.threeDSettings.viewAngle = parseFloat(document.getElementById('viewAngleInput').value);
                this.threeDSettings.rotationAngle = parseFloat(document.getElementById('rotationAngleInput').value);
                this.threeDSettings.heightScale = parseFloat(document.getElementById('heightScaleInput').value);
                this.threeDSettings.lightAngle = parseFloat(document.getElementById('lightAngleInput').value);
                this.threeDSettings.shadowIntensity = parseFloat(document.getElementById('shadowIntensityInput').value);
                this.threeDSettings.wallColorIntensity = parseFloat(document.getElementById('wallColorIntensityInput').value);
                this.threeDSettings.defaultBuildingColor = document.getElementById('defaultBuildingColorInput').value;
                this.threeDSettings.show3DLabels = document.getElementById('show3DLabelsInput').checked;
                this.threeDSettings.showLandscape = document.getElementById('showLandscapeInput').checked;
                
                // 更新工具栏滑块
                document.getElementById('viewAngleSlider').value = this.threeDSettings.viewAngle;
                document.getElementById('rotationAngleSlider').value = this.threeDSettings.rotationAngle;
                document.getElementById('heightScaleSlider').value = this.threeDSettings.heightScale;
                
                // 更新复选框
                document.getElementById('show3DLabelsCheck').checked = this.threeDSettings.show3DLabels;
                document.getElementById('showLandscapeCheck').checked = this.threeDSettings.showLandscape;
                
                this.redraw();
            }

            apply3DSettings() {
                this.threeDSettings.viewAngle = parseFloat(document.getElementById('viewAngleInput').value);
                this.threeDSettings.rotationAngle = parseFloat(document.getElementById('rotationAngleInput').value);
                this.threeDSettings.heightScale = parseFloat(document.getElementById('heightScaleInput').value);
                this.threeDSettings.lightAngle = parseFloat(document.getElementById('lightAngleInput').value);
                this.threeDSettings.shadowIntensity = parseFloat(document.getElementById('shadowIntensityInput').value);
                this.threeDSettings.defaultHeight = parseFloat(document.getElementById('defaultHeightInput').value);
                this.threeDSettings.wallColorIntensity = parseFloat(document.getElementById('wallColorIntensityInput').value);
                this.threeDSettings.defaultBuildingColor = document.getElementById('defaultBuildingColorInput').value;
                this.threeDSettings.show3DLabels = document.getElementById('show3DLabelsInput').checked;
                this.threeDSettings.showLandscape = document.getElementById('showLandscapeInput').checked;
                
                // 更新工具栏
                document.getElementById('viewAngleSlider').value = this.threeDSettings.viewAngle;
                document.getElementById('rotationAngleSlider').value = this.threeDSettings.rotationAngle;
                document.getElementById('heightScaleSlider').value = this.threeDSettings.heightScale;
                document.getElementById('show3DLabelsCheck').checked = this.threeDSettings.show3DLabels;
                document.getElementById('showLandscapeCheck').checked = this.threeDSettings.showLandscape;
                
                this.redraw();
                this.closeDialog();
            }

            reset3DSettings() {
                this.threeDSettings = new ThreeDSettings();
                document.getElementById('viewAngleSlider').value = this.threeDSettings.viewAngle;
                document.getElementById('rotationAngleSlider').value = this.threeDSettings.rotationAngle;
                document.getElementById('heightScaleSlider').value = this.threeDSettings.heightScale;
                document.getElementById('show3DLabelsCheck').checked = this.threeDSettings.show3DLabels;
                document.getElementById('showLandscapeCheck').checked = this.threeDSettings.showLandscape;
                this.redraw();
                this.closeDialog();
            }

            editBuildingHeight() {
                if (this.selectedWay) {
                    const way = this.ways.get(this.selectedWay);
                    const tags = way.tags || {};
                    
                    if (!tags.building) {
                        alert("选中的对象不是建筑物！");
                        return;
                    }
                    
                    const currentHeight = this.getBuildingHeight(tags);
                    const newHeight = prompt(`请输入建筑高度(米)，当前: ${currentHeight}m:`, currentHeight);
                    
                    if (newHeight !== null && !isNaN(parseFloat(newHeight))) {
                        const oldTags = structuredClone(tags);
                        const newTags = structuredClone(tags);
                        newTags.height = parseFloat(newHeight).toString();
                        
                        const command = new ModifyTagsCommand(this, 'way', this.selectedWay, oldTags, newTags);
                        this.executeCommand(command);
                        
                        this.redraw();
                        this.updateSelectionInfo();
                    }
                } else if (this.selectedWays.size > 0) {
                    const height = prompt("请输入建筑高度(米):");
                    if (height !== null && !isNaN(parseFloat(height))) {
                        for (const wayId of this.selectedWays) {
                            const way = this.ways.get(wayId);
                            const tags = way.tags || {};
                            
                            if (tags.building) {
                                const oldTags = structuredClone(tags);
                                const newTags = structuredClone(tags);
                                newTags.height = parseFloat(height).toString();
                                
                                const command = new ModifyTagsCommand(this, 'way', wayId, oldTags, newTags);
                                this.executeCommand(command);
                            }
                        }
                        
                        this.redraw();
                        this.updateSelectionInfo();
                    }
                } else {
                    alert("请先选择一个或多个建筑物！");
                }
            }

            editBuildingColor() {
                if (this.selectedWay) {
                    const way = this.ways.get(this.selectedWay);
                    const tags = way.tags || {};
                    
                    if (!tags.building) {
                        alert("选中的对象不是建筑物！");
                        return;
                    }
                    
                    // 确保颜色格式正确
                    const currentColor = this.getBuildingColor(tags);
                    const hexColor = this.ensureHexColor(currentColor);
                    
                    // 创建对话框而不是简单的文件选择器
                    this.showColorPickerDialog('单个建筑', hexColor, (newColor) => {
                        const oldTags = structuredClone(tags);
                        const newTags = structuredClone(tags);
                        newTags['building:colour'] = newColor;
                        
                        const command = new ModifyTagsCommand(this, 'way', this.selectedWay, oldTags, newTags);
                        this.executeCommand(command);
                        
                        this.redraw();
                        this.updateSelectionInfo();
                    });
                    
                } else if (this.selectedWays.size > 0) {
                    const hexColor = this.ensureHexColor(this.threeDSettings.defaultBuildingColor);
                    
                    this.showColorPickerDialog('多个建筑', hexColor, (newColor) => {
                        for (const wayId of this.selectedWays) {
                            const way = this.ways.get(wayId);
                            const tags = way.tags || {};
                            
                            if (tags.building) {
                                const oldTags = structuredClone(tags);
                                const newTags = structuredClone(tags);
                                newTags['building:colour'] = newColor;
                                
                                const command = new ModifyTagsCommand(this, 'way', wayId, oldTags, newTags);
                                this.executeCommand(command);
                            }
                        }
                        
                        this.redraw();
                        this.updateSelectionInfo();
                    });
                } else {
                    alert("请先选择一个或多个建筑物！");
                }
            }

            showColorPickerDialog(title, currentColor, onColorChange) {
                const dialog = this.createDialog(`编辑${title}颜色`, 350, 250);
                
                dialog.innerHTML = `
                    <h3>编辑${title}颜色</h3>
                    
                    <div class="form-row">
                        <label>当前颜色:</label>
                        <div class="color-preview" id="currentColorPreview" style="background-color: ${currentColor}; width: 60px; height: 30px; border: 2px solid #000; display: inline-block;"></div>
                        <span id="currentColorText">${currentColor}</span>
                    </div>
                    
                    <div class="form-row">
                        <label>选择新颜色:</label>
                        <input type="color" id="colorPicker" value="${currentColor}" style="width: 60px; height: 30px;">
                        <input type="text" id="colorText" value="${currentColor}" style="width: 80px; margin-left: 10px;" placeholder="#RRGGBB">
                    </div>
                    
                    <div class="form-row">
                        <label>预设颜色:</label>
                    </div>
                    <div class="form-row">
                        <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                            <div class="color-preset" style="background-color: #F0F0F0; width: 25px; height: 25px; border: 1px solid #000; cursor: pointer;" title="浅灰" data-color="#F0F0F0"></div>
                            <div class="color-preset" style="background-color: #8B4513; width: 25px; height: 25px; border: 1px solid #000; cursor: pointer;" title="棕色" data-color="#8B4513"></div>
                            <div class="color-preset" style="background-color: #DC143C; width: 25px; height: 25px; border: 1px solid #000; cursor: pointer;" title="红色" data-color="#DC143C"></div>
                            <div class="color-preset" style="background-color: #FF8C00; width: 25px; height: 25px; border: 1px solid #000; cursor: pointer;" title="橙色" data-color="#FF8C00"></div>
                            <div class="color-preset" style="background-color: #FFD700; width: 25px; height: 25px; border: 1px solid #000; cursor: pointer;" title="金色" data-color="#FFD700"></div>
                            <div class="color-preset" style="background-color: #32CD32; width: 25px; height: 25px; border: 1px solid #000; cursor: pointer;" title="绿色" data-color="#32CD32"></div>
                            <div class="color-preset" style="background-color: #4169E1; width: 25px; height: 25px; border: 1px solid #000; cursor: pointer;" title="蓝色" data-color="#4169E1"></div>
                            <div class="color-preset" style="background-color: #8A2BE2; width: 25px; height: 25px; border: 1px solid #000; cursor: pointer;" title="紫色" data-color="#8A2BE2"></div>
                            <div class="color-preset" style="background-color: #A0A0A0; width: 25px; height: 25px; border: 1px solid #000; cursor: pointer;" title="灰色" data-color="#A0A0A0"></div>
                            <div class="color-preset" style="background-color: #2F4F4F; width: 25px; height: 25px; border: 1px solid #000; cursor: pointer;" title="深灰" data-color="#2F4F4F"></div>
                        </div>
                    </div>
                    
                    <div class="dialog-buttons">
                        <button onclick="editor.applyColorChange('${currentColor}')">确定</button>
                        <button onclick="editor.closeDialog()">取消</button>
                    </div>
                `;
                
                // 保存回调函数
                this.colorChangeCallback = onColorChange;
                
                // 绑定颜色选择器事件
                const colorPicker = document.getElementById('colorPicker');
                const colorText = document.getElementById('colorText');
                const currentColorPreview = document.getElementById('currentColorPreview');
                const currentColorText = document.getElementById('currentColorText');
                
                const updateColor = (color) => {
                    const hexColor = this.ensureHexColor(color);
                    colorPicker.value = hexColor;
                    colorText.value = hexColor;
                    currentColorPreview.style.backgroundColor = hexColor;
                    currentColorText.textContent = hexColor;
                };
                
                colorPicker.addEventListener('change', (e) => updateColor(e.target.value));
                colorText.addEventListener('change', (e) => updateColor(e.target.value));
                colorText.addEventListener('keyup', (e) => {
                    if (e.target.value.match(/^#[0-9A-Fa-f]{6}$/)) {
                        updateColor(e.target.value);
                    }
                });
                
                // 绑定预设颜色点击事件
                const presetColors = dialog.querySelectorAll('.color-preset');
                presetColors.forEach(preset => {
                    preset.addEventListener('click', () => {
                        updateColor(preset.dataset.color);
                    });
                });
            }

            applyColorChange(originalColor) {
                const colorText = document.getElementById('colorText');
                const newColor = colorText.value;
                
                if (!newColor.match(/^#[0-9A-Fa-f]{6}$/)) {
                    alert('请输入有效的颜色格式 (例如: #FF0000)');
                    return;
                }
                
                if (this.colorChangeCallback) {
                    this.colorChangeCallback(newColor);
                }
                
                this.closeDialog();
            }

            ensureHexColor(color) {
                if (!color || color === 'transparent') {
                    return this.threeDSettings.defaultBuildingColor;
                }
                
                // 如果已经是hex格式，直接返回
                if (color.match(/^#[0-9A-Fa-f]{6}$/)) {
                    return color;
                }
                
                // 处理一些常见的颜色名称
                const colorNames = {
                    'red': '#FF0000',
                    'green': '#00FF00',
                    'blue': '#0000FF',
                    'yellow': '#FFFF00',
                    'orange': '#FFA500',
                    'purple': '#800080',
                    'brown': '#A52A2A',
                    'pink': '#FFC0CB',
                    'gray': '#808080',
                    'grey': '#808080',
                    'black': '#000000',
                    'white': '#FFFFFF'
                };
                
                const lowerColor = color.toLowerCase();
                if (colorNames[lowerColor]) {
                    return colorNames[lowerColor];
                }
                
                // 处理rgb格式
                const rgbMatch = color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
                if (rgbMatch) {
                    const r = parseInt(rgbMatch[1]).toString(16).padStart(2, '0');
                    const g = parseInt(rgbMatch[2]).toString(16).padStart(2, '0');
                    const b = parseInt(rgbMatch[3]).toString(16).padStart(2, '0');
                    return `#${r}${g}${b}`.toUpperCase();
                }
                
                // 如果无法转换，返回默认颜色
                return this.threeDSettings.defaultBuildingColor;
            }

            randomizeBuildingHeights() {
                if (confirm("确定要为所有建筑物随机分配高度吗？")) {
                    for (const [wayId, wayData] of this.ways) {
                        const tags = wayData.tags || {};
                        if (tags.building) {
                            const minHeight = 5;
                            const maxHeight = 50;
                            const randomHeight = Math.random() * (maxHeight - minHeight) + minHeight;
                            
                            const oldTags = structuredClone(tags);
                            const newTags = structuredClone(tags);
                            newTags.height = randomHeight.toFixed(1);
                            
                            const command = new ModifyTagsCommand(this, 'way', wayId, oldTags, newTags);
                            this.executeCommand(command);
                        }
                    }
                    
                    this.redraw();
                    alert("建筑物高度已随机分配！");
                }
            }

            clearBuildingHeights() {
                if (confirm("确定要清除所有建筑物的高度数据吗？")) {
                    for (const [wayId, wayData] of this.ways) {
                        const tags = wayData.tags || {};
                        if (tags.building && (tags.height || tags.levels || tags['building:levels'] || tags['building:height'])) {
                            const oldTags = structuredClone(tags);
                            const newTags = structuredClone(tags);
                            
                            delete newTags.height;
                            delete newTags.levels;
                            delete newTags['building:levels'];
                            delete newTags['building:height'];
                            
                            const command = new ModifyTagsCommand(this, 'way', wayId, oldTags, newTags);
                            this.executeCommand(command);
                        }
                    }
                    
                    this.redraw();
                    alert("建筑物高度数据已清除！");
                }
            }

            onClick(event) {
                const rect = this.canvas.getBoundingClientRect();
                const canvasX = event.clientX - rect.left;
                const canvasY = event.clientY - rect.top;
                const [worldX, worldY] = this.canvasToWorld(canvasX, canvasY);
                
                const shiftPressed = event.shiftKey;
                const ctrlPressed = event.ctrlKey;
                
                let adjustedX = worldX;
                let adjustedY = worldY;
                if (this.gridSettings.snapToGrid) {
                    [adjustedX, adjustedY] = this.snapToGrid(worldX, worldY);
                }
                
                if (this.mode === "select") {
                    this.handleSelect(canvasX, canvasY, shiftPressed, ctrlPressed);
                } else if (this.mode === "box_select") {
                    this.startBoxSelect(canvasX, canvasY);
                } else if (this.mode === "add_node") {
                    this.addNode(adjustedX, adjustedY);
                } else if (this.mode === "add_way") {
                    this.handleWayCreation(canvasX, canvasY);
                } else if (this.mode === "add_polygon") {
                    this.handlePolygonCreation(canvasX, canvasY);
                } else if (this.mode === "measure") {
                    this.addMeasurePoint(worldX, worldY);
                }
                
                this.dragStart = [canvasX, canvasY];
                
                if (this.selectedNode && this.nodes.has(this.selectedNode)) {
                    this.draggingNode = true;
                    const node = this.nodes.get(this.selectedNode);
                    this.nodeStartPos = [node.lon, node.lat];
                }
            }

            onRightClick(event) {
                if (this.mode === "add_way" || this.mode === "add_polygon") {
                    if (this.creatingWay.length > 0) {
                        this.finishCreation();
                    }
                }
            }

            onMouseMove(event) {
                const rect = this.canvas.getBoundingClientRect();
                const canvasX = event.clientX - rect.left;
                const canvasY = event.clientY - rect.top;
                const [worldX, worldY] = this.canvasToWorld(canvasX, canvasY);
                
                this.updateCoordinateDisplay(worldX, worldY);
                
                if (this.dragStart) {
                    const dx = canvasX - this.dragStart[0];
                    const dy = canvasY - this.dragStart[1];
                    
                    if (this.mode === "box_select") {
                        this.updateBoxSelect(canvasX, canvasY);
                    } else if (this.mode === "select" && this.selectedNode && this.draggingNode) {
                        this.moveSelectedNode(dx, dy);
                    } else if (this.mode === "select" && !this.selectedNode) {
                        this.centerX -= dx / this.scale;
                        this.centerY += dy / this.scale;
                        this.redraw();
                    }
                    
                    this.dragStart = [canvasX, canvasY];
                }
            }

            onRelease(event) {
                const rect = this.canvas.getBoundingClientRect();
                const canvasX = event.clientX - rect.left;
                const canvasY = event.clientY - rect.top;
                const shiftPressed = event.shiftKey;
                const ctrlPressed = event.ctrlKey;
                
                if (this.mode === "box_select" && this.boxSelecting) {
                    this.finishBoxSelect(canvasX, canvasY, shiftPressed, ctrlPressed);
                }
                
                if (this.draggingNode && this.selectedNode && this.nodeStartPos) {
                    const node = this.nodes.get(this.selectedNode);
                    const endPos = [node.lon, node.lat];
                    
                    if (Math.abs(endPos[0] - this.nodeStartPos[0]) > 1e-8 || 
                        Math.abs(endPos[1] - this.nodeStartPos[1]) > 1e-8) {
                        const command = new MoveNodeCommand(this, this.selectedNode, this.nodeStartPos, endPos);
                        this.undoStack.push(command);
                        this.redoStack = [];
                        this.updateUndoRedoButtons();
                    }
                }
                
                this.dragStart = null;
                this.draggingNode = false;
                this.nodeStartPos = null;
            }

            onScroll(event) {
                event.preventDefault();
                const factor = event.deltaY > 0 ? 0.9 : 1.1;
                this.scale *= factor;
                this.scale = Math.max(1000, Math.min(1000000, this.scale));
                this.redraw();
                this.updateViewInfo();
            }

            onDoubleClick(event) {
                console.log('Double click detected');
            }

            onKey(event) {
                switch(event.key) {
                    case 'Delete':
                        this.deleteSelected();
                        break;
                    case 'r':
                    case 'R':
                        if (event.shiftKey) {
                            this.rotateView(-15);
                        } else {
                            this.rotateView(15);
                        }
                        break;
                    case 'Escape':
                        if (this.mode === "measure") {
                            this.clearMeasurement();
                        } else {
                            this.cancelCreation();
                        }
                        break;
                    case 'Enter':
                        if (this.creatingWay.length > 0) {
                            this.finishCreation();
                        }
                        break;
                    case 'e':
                    case 'E':
                        this.editTags();
                        break;
                    case 'g':
                    case 'G':
                        document.getElementById('gridCheck').checked = !document.getElementById('gridCheck').checked;
                        this.toggleGrid();
                        break;
                    case 'm':
                    case 'M':
                        this.clearMeasurement();
                        break;
                    case 'c':
                    case 'C':
                        if (this.renderMode === '3d') {
                            this.editBuildingColor();
                        } else {
                            const coordSelect = document.getElementById('coordSelect');
                            coordSelect.value = coordSelect.value === 'geographic' ? 'scene' : 'geographic';
                            this.onCoordSystemChange();
                        }
                        break;
                    case 'h':
                    case 'H':
                        if (this.renderMode === '3d') {
                            this.editBuildingHeight();
                        }
                        break;
                }
                
                if (event.ctrlKey && event.key === 'z') {
                    this.undo();
                }
                
                if (event.ctrlKey && event.key === 'y') {
                    this.redo();
                }
                
                if (event.ctrlKey && event.key === 'a') {
                    event.preventDefault();
                    this.selectAllPolygons();
                }
            }

            canvasToWorld(canvasX, canvasY) {
                const centerCanvasX = this.canvas.width / 2;
                const centerCanvasY = this.canvas.height / 2;
                
                const relX = canvasX - centerCanvasX;
                const relY = canvasY - centerCanvasY;
                
                const rad = -this.rotation * Math.PI / 180;
                const cosR = Math.cos(rad);
                const sinR = Math.sin(rad);
                
                const rotatedX = relX * cosR - relY * sinR;
                const rotatedY = relX * sinR + relY * cosR;
                
                const worldX = this.centerX + rotatedX / this.scale;
                const worldY = this.centerY - rotatedY / this.scale;
                
                return [worldX, worldY];
            }

            worldToCanvas(worldX, worldY) {
                const relX = (worldX - this.centerX) * this.scale;
                const relY = -(worldY - this.centerY) * this.scale;
                
                const rad = this.rotation * Math.PI / 180;
                const cosR = Math.cos(rad);
                const sinR = Math.sin(rad);
                
                const rotatedX = relX * cosR - relY * sinR;
                const rotatedY = relX * sinR + relY * cosR;
                
                const centerCanvasX = this.canvas.width / 2;
                const centerCanvasY = this.canvas.height / 2;
                
                const canvasX = centerCanvasX + rotatedX;
                const canvasY = centerCanvasY + rotatedY;
                
                return [canvasX, canvasY];
            }

            snapToGrid(x, y) {
                const dx = x - this.gridSettings.originX;
                const dy = y - this.gridSettings.originY;
                
                const metersPerDegree = this.metersPerDegreeLat * Math.cos(y * Math.PI / 180);
                const dxMeters = dx * metersPerDegree;
                const dyMeters = dy * this.metersPerDegreeLat;
                
                const gridSize = this.gridSettings.gridSizeMeters;
                const snappedDxMeters = Math.round(dxMeters / gridSize) * gridSize;
                const snappedDyMeters = Math.round(dyMeters / gridSize) * gridSize;
                
                const snappedDx = snappedDxMeters / metersPerDegree;
                const snappedDy = snappedDyMeters / this.metersPerDegreeLat;
                
                return [this.gridSettings.originX + snappedDx, this.gridSettings.originY + snappedDy];
            }

            updateCoordinateDisplay(worldX, worldY) {
                let coordText;
                if (this.coordSystem.coordType === "geographic") {
                    coordText = `经度: ${worldX.toFixed(6)}, 纬度: ${worldY.toFixed(6)}`;
                } else {
                    const [sceneX, sceneY] = this.coordSystem.geographicToScene(worldX, worldY);
                    coordText = `X: ${sceneX.toFixed(2)}m, Y: ${sceneY.toFixed(2)}m`;
                }
                
                document.getElementById('coordLabel').textContent = coordText;
                
                const metersPerDegree = this.metersPerDegreeLat * Math.cos(worldY * Math.PI / 180);
                const metersPerPixel = metersPerDegree / this.scale;
                const scaleRatio = Math.round(metersPerPixel);
                document.getElementById('scaleLabel').textContent = `1:${scaleRatio}`;
            }

            updateCreateStatus() {
                let status = "无";
                if (this.creatingWay.length > 0) {
                    if (this.mode === "add_way") {
                        status = `创建路径: ${this.creatingWay.length}个节点`;
                    } else if (this.mode === "add_polygon") {
                        status = `创建多边形: ${this.creatingWay.length}个节点`;
                    }
                } else if (this.mode === "measure") {
                    if (this.measurePoints.length > 0) {
                        status = `测量: ${this.measurePoints.length}个点`;
                    } else {
                        status = "测量模式";
                    }
                }
                document.getElementById('createStatusLabel').textContent = status;
            }

            updateGridStatus() {
                const gridStatusLabel = document.getElementById('gridStatusLabel');
                if (this.gridSettings.showGrid) {
                    let status = `显示 ${this.gridSettings.gridSizeMeters}m`;
                    if (this.gridSettings.snapToGrid) {
                        status += " (吸附)";
                    }
                    gridStatusLabel.textContent = status;
                    gridStatusLabel.style.color = "green";
                } else {
                    gridStatusLabel.textContent = "隐藏";
                    gridStatusLabel.style.color = "gray";
                }
            }

            updateMultiselectInfo() {
                const multiselectLabel = document.getElementById('multiselectLabel');
                if (this.selectedWays.size > 0) {
                    multiselectLabel.textContent = `已选择 ${this.selectedWays.size} 个多边形`;
                    multiselectLabel.style.color = "green";
                } else {
                    multiselectLabel.textContent = "未选择";
                    multiselectLabel.style.color = "orange";
                }
            }

            updateViewInfo() {
                const scaleFactor = this.scale / 100000;
                let viewInfo = `缩放: ${scaleFactor.toFixed(2)}<br>旋转: ${this.rotation}°`;
                
                if (this.coordSystem.coordType === "scene") {
                    viewInfo += `<br>场景原点: (${this.coordSystem.sceneOriginLon.toFixed(3)}, ${this.coordSystem.sceneOriginLat.toFixed(3)})`;
                }
                
                if (this.renderMode === '3d') {
                    viewInfo += `<br>3D俯视: ${this.threeDSettings.viewAngle}°`;
                    viewInfo += `<br>3D旋转: ${this.threeDSettings.rotationAngle}°`;
                    viewInfo += `<br>高度缩放: ${this.threeDSettings.heightScale}x`;
                }
                
                document.getElementById('viewLabel').innerHTML = viewInfo;
            }

            redraw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.fillStyle = 'white';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.drawGrid();
                this.drawOSMData();
                this.drawCompass();
                this.drawBoxSelect();
                this.drawMeasurement();
                this.updateViewInfo();
            }

            drawGrid() {
                if (!this.gridSettings.showGrid) return;
                
                const canvasWidth = this.canvas.width;
                const canvasHeight = this.canvas.height;
                
                const [originCanvasX, originCanvasY] = this.worldToCanvas(
                    this.gridSettings.originX, this.gridSettings.originY);
                
                const metersPerDegree = this.metersPerDegreeLat * Math.cos(this.centerY * Math.PI / 180);
                const pixelsPerMeter = this.scale / metersPerDegree;
                let gridSpacing = this.gridSettings.gridSizeMeters * pixelsPerMeter;
                
                if (gridSpacing < 10) {
                    const multiplier = Math.max(1, Math.floor(20 / gridSpacing));
                    gridSpacing *= multiplier;
                } else if (gridSpacing > 300) {
                    const divisor = Math.max(1, Math.floor(gridSpacing / 100));
                    gridSpacing /= divisor;
                }
                
                this.ctx.strokeStyle = this.gridSettings.gridColor;
                this.ctx.lineWidth = 1;
                
                // 绘制垂直线
                let x = originCanvasX % gridSpacing;
                let lineCount = 0;
                while (x < canvasWidth && lineCount < 200) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, canvasHeight);
                    this.ctx.stroke();
                    x += gridSpacing;
                    lineCount++;
                }
                
                x = originCanvasX % gridSpacing - gridSpacing;
                lineCount = 0;
                while (x >= 0 && lineCount < 200) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, canvasHeight);
                    this.ctx.stroke();
                    x -= gridSpacing;
                    lineCount++;
                }
                
                // 绘制水平线
                let y = originCanvasY % gridSpacing;
                lineCount = 0;
                while (y < canvasHeight && lineCount < 200) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(canvasWidth, y);
                    this.ctx.stroke();
                    y += gridSpacing;
                    lineCount++;
                }
                
                y = originCanvasY % gridSpacing - gridSpacing;
                lineCount = 0;
                while (y >= 0 && lineCount < 200) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(canvasWidth, y);
                    this.ctx.stroke();
                    y -= gridSpacing;
                    lineCount++;
                }
                
                // 绘制坐标轴
                this.ctx.strokeStyle = this.gridSettings.axisColor;
                this.ctx.lineWidth = 2;
                
                if (0 <= originCanvasX && originCanvasX <= canvasWidth) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(originCanvasX, 0);
                    this.ctx.lineTo(originCanvasX, canvasHeight);
                    this.ctx.stroke();
                }
                
                if (0 <= originCanvasY && originCanvasY <= canvasHeight) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, originCanvasY);
                    this.ctx.lineTo(canvasWidth, originCanvasY);
                    this.ctx.stroke();
                }
                
                // 原点标记
                if (0 <= originCanvasX && originCanvasX <= canvasWidth && 
                    0 <= originCanvasY && originCanvasY <= canvasHeight) {
                    this.ctx.fillStyle = this.gridSettings.axisColor;
                    this.ctx.beginPath();
                    this.ctx.arc(originCanvasX, originCanvasY, 5, 0, 2 * Math.PI);
                    this.ctx.fill();
                    
                    if (this.gridSettings.showCoordinates) {
                        let coordText;
                        if (this.coordSystem.coordType === "geographic") {
                            coordText = `(${this.gridSettings.originX.toFixed(3)},${this.gridSettings.originY.toFixed(3)})`;
                        } else {
                            const [sceneX, sceneY] = this.coordSystem.geographicToScene(
                                this.gridSettings.originX, this.gridSettings.originY);
                            coordText = `(${sceneX.toFixed(1)}m,${sceneY.toFixed(1)}m)`;
                        }
                        
                        this.ctx.fillStyle = this.gridSettings.axisColor;
                        this.ctx.font = '9px Arial';
                        this.ctx.fillText(coordText, originCanvasX + 15, originCanvasY - 15);
                    }
                }
            }

            drawCompass() {
                if (!document.getElementById('compassCheck').checked) return;
                
                const compassX = this.canvas.width - this.compassSize - 20;
                const compassY = 20 + this.compassSize / 2;
                const radius = this.compassSize / 2;
                
                this.ctx.strokeStyle = 'black';
                this.ctx.lineWidth = 2;
                this.ctx.fillStyle = 'white';
                this.ctx.beginPath();
                this.ctx.arc(compassX, compassY, radius, 0, 2 * Math.PI);
                this.ctx.fill();
                this.ctx.stroke();
                
                const directions = [
                    [0, 'N'], [30, ''], [60, ''], [90, 'E'],
                    [120, ''], [150, ''], [180, 'S'], [210, ''],
                    [240, ''], [270, 'W'], [300, ''], [330, '']
                ];
                
                for (const [angle, label] of directions) {
                    const screenAngle = (angle - 90) * Math.PI / 180;
                    const x1 = compassX + (radius - 10) * Math.cos(screenAngle);
                    const y1 = compassY + (radius - 10) * Math.sin(screenAngle);
                    const x2 = compassX + radius * Math.cos(screenAngle);
                    const y2 = compassY + radius * Math.sin(screenAngle);
                    
                    this.ctx.strokeStyle = 'black';
                    this.ctx.lineWidth = label ? 2 : 1;
                    this.ctx.beginPath();
                    this.ctx.moveTo(x1, y1);
                    this.ctx.lineTo(x2, y2);
                    this.ctx.stroke();
                    
                    if (label) {
                        const textX = compassX + (radius + 12) * Math.cos(screenAngle);
                        const textY = compassY + (radius + 12) * Math.sin(screenAngle);
                        this.ctx.fillStyle = 'black';
                        this.ctx.font = 'bold 10px Arial';
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'middle';
                        this.ctx.fillText(label, textX, textY);
                    }
                }
                
                const northAngle = (-this.rotation - 90) * Math.PI / 180;
                const northX = compassX + (radius - 5) * Math.cos(northAngle);
                const northY = compassY + (radius - 5) * Math.sin(northAngle);
                
                this.ctx.strokeStyle = 'red';
                this.ctx.lineWidth = 3;
                this.ctx.beginPath();
                this.ctx.moveTo(compassX, compassY);
                this.ctx.lineTo(northX, northY);
                this.ctx.stroke();
                
                const arrowSize = 8;
                const arrowAngle1 = northAngle + Math.PI * 5/6;
                const arrowAngle2 = northAngle + Math.PI * 7/6;
                
                const arrowX1 = northX + arrowSize * Math.cos(arrowAngle1);
                const arrowY1 = northY + arrowSize * Math.sin(arrowAngle1);
                const arrowX2 = northX + arrowSize * Math.cos(arrowAngle2);
                const arrowY2 = northY + arrowSize * Math.sin(arrowAngle2);
                
                this.ctx.fillStyle = 'red';
                this.ctx.beginPath();
                this.ctx.moveTo(northX, northY);
                this.ctx.lineTo(arrowX1, arrowY1);
                this.ctx.lineTo(arrowX2, arrowY2);
                this.ctx.closePath();
                this.ctx.fill();
                
                this.ctx.fillStyle = 'black';
                this.ctx.beginPath();
                this.ctx.arc(compassX, compassY, 3, 0, 2 * Math.PI);
                this.ctx.fill();
                
                this.ctx.fillStyle = 'black';
                this.ctx.font = '9px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(`旋转: ${Math.round(this.rotation)}°`, compassX, compassY + radius + 20);
                
                this.ctx.fillStyle = 'red';
                this.ctx.font = '8px Arial';
                this.ctx.fillText('红色箭头指向北', compassX, compassY + radius + 35);
            }

            drawOSMData() {
                const showGeometry = this.renderMode === "geometry" || this.renderMode === "both";
                const showRendered = this.renderMode === "rendered" || this.renderMode === "both";
                const show3D = this.renderMode === "3d";
                
                // 绘制ways
                for (const [wayId, wayData] of this.ways) {
                    const nodeIds = wayData.nodes;
                    if (nodeIds.length < 2) continue;
                    
                    const points = [];
                    for (const nodeId of nodeIds) {
                        if (this.nodes.has(nodeId)) {
                            const node = this.nodes.get(nodeId);
                            const [canvasX, canvasY] = this.worldToCanvas(node.lon, node.lat);
                            points.push([canvasX, canvasY]);
                        }
                    }
                    
                    if (points.length >= 2) {
                        const tags = wayData.tags || {};
                        const isClosed = nodeIds.length > 2 && nodeIds[0] === nodeIds[nodeIds.length - 1];
                        const isSelected = wayId === this.selectedWay;
                        const isMultiSelected = this.selectedWays.has(wayId);
                        
                        // 3D模式下的渲染
                        if (show3D) {
                            // 建筑物3D渲染
                            if (tags.building && isClosed) {
                                this.drawBuilding3D(points, tags, wayId);
                            }
                            // 地貌3D渲染
                            else if (isClosed && (tags.landuse || tags.natural || tags.leisure)) {
                                this.drawLandscape3D(points, tags, wayId);
                            }
                            // 其他对象3D渲染
                            else {
                                this.drawWay3D(points, tags, isClosed, isSelected, isMultiSelected);
                            }
                        } else {
                            // 2D渲染
                            if (showRendered && Object.keys(tags).length > 0) {
                                this.drawRenderedWay(points, tags, isClosed, isMultiSelected);
                            }
                            
                            if (showGeometry) {
                                this.drawGeometryWay(points, isClosed, isSelected, isMultiSelected);
                            }
                        }
                        
                        // 绘制标签
                        if ((this.showLabels && !show3D) || (show3D && this.threeDSettings.show3DLabels)) {
                            if (tags.name) {
                                this.drawWayLabel(points, tags.name, wayId);
                            }
                        }
                    }
                }
                
                // 绘制正在创建的路径
                if (this.creatingWay.length > 0) {
                    const points = [];
                    for (const nodeId of this.creatingWay) {
                        if (this.nodes.has(nodeId)) {
                            const node = this.nodes.get(nodeId);
                            const [canvasX, canvasY] = this.worldToCanvas(node.lon, node.lat);
                            points.push([canvasX, canvasY]);
                        }
                    }
                    
                    if (points.length >= 2) {
                        this.ctx.strokeStyle = 'orange';
                        this.ctx.lineWidth = 3;
                        this.ctx.setLineDash([5, 5]);
                        this.ctx.beginPath();
                        this.ctx.moveTo(points[0][0], points[0][1]);
                        for (let i = 1; i < points.length; i++) {
                            this.ctx.lineTo(points[i][0], points[i][1]);
                        }
                        this.ctx.stroke();
                        this.ctx.setLineDash([]);
                    }
                }
                
                // 绘制nodes
                if (showGeometry || !show3D) {
                    for (const [nodeId, nodeData] of this.nodes) {
                        const [canvasX, canvasY] = this.worldToCanvas(nodeData.lon, nodeData.lat);
                        
                        if (canvasX >= -10 && canvasX <= this.canvas.width + 10 &&
                            canvasY >= -10 && canvasY <= this.canvas.height + 10) {
                            
                            const isInCreation = this.creatingWay.includes(nodeId);
                            const isSelected = nodeId === this.selectedNode;
                            const isModified = nodeData.modified || false;
                            
                            let color, size;
                            if (isSelected) {
                                color = 'red';
                                size = 8;
                            } else if (isModified) {
                                color = 'purple';
                                size = 6;
                            } else if (isInCreation) {
                                color = 'orange';
                                size = 6;
                            } else {
                                color = 'blue';
                                size = 4;
                            }
                            
                            this.ctx.fillStyle = color;
                            this.ctx.strokeStyle = 'white';
                            this.ctx.lineWidth = 1;
                            this.ctx.beginPath();
                            this.ctx.arc(canvasX, canvasY, size, 0, 2 * Math.PI);
                            this.ctx.fill();
                            this.ctx.stroke();
                            
                            // 绘制节点标签
                            if (((this.showLabels && !show3D) || (show3D && this.threeDSettings.show3DLabels)) 
                                && nodeData.tags && nodeData.tags.name) {
                                this.drawNodeLabel(canvasX, canvasY, nodeData.tags.name);
                            }
                        }
                    }
                }
            }

            drawRenderedWay(points, tags, isClosed, isMultiSelected) {
                if (isClosed) {
                    const buildingStyle = this.getBuildingStyle(tags);
                    const landscapeStyle = this.getLandscapeStyle(tags);
                    
                    if (buildingStyle) {
                        this.ctx.fillStyle = isMultiSelected ? '#FFFF00' : buildingStyle.fill;
                        this.ctx.strokeStyle = buildingStyle.outline;
                        this.ctx.lineWidth = buildingStyle.width;
                        this.ctx.beginPath();
                        this.ctx.moveTo(points[0][0], points[0][1]);
                        for (let i = 1; i < points.length; i++) {
                            this.ctx.lineTo(points[i][0], points[i][1]);
                        }
                        this.ctx.closePath();
                        this.ctx.fill();
                        this.ctx.stroke();
                    } else if (landscapeStyle) {
                        this.ctx.fillStyle = isMultiSelected ? '#FFFF00' : landscapeStyle.fill;
                        this.ctx.strokeStyle = landscapeStyle.outline;
                        this.ctx.lineWidth = landscapeStyle.width;
                        this.ctx.beginPath();
                        this.ctx.moveTo(points[0][0], points[0][1]);
                        for (let i = 1; i < points.length; i++) {
                            this.ctx.lineTo(points[i][0], points[i][1]);
                        }
                        this.ctx.closePath();
                        this.ctx.fill();
                        this.ctx.stroke();
                    } else {
                        const style = this.getWayStyle(tags);
                        this.ctx.strokeStyle = isMultiSelected ? 'yellow' : style.fill;
                        this.ctx.lineWidth = style.width;
                        this.ctx.fillStyle = 'transparent';
                        this.ctx.beginPath();
                        this.ctx.moveTo(points[0][0], points[0][1]);
                        for (let i = 1; i < points.length; i++) {
                            this.ctx.lineTo(points[i][0], points[i][1]);
                        }
                        this.ctx.closePath();
                        this.ctx.stroke();
                    }
                } else {
                    const style = this.getWayStyle(tags);
                    this.ctx.strokeStyle = isMultiSelected ? 'yellow' : style.fill;
                    this.ctx.lineWidth = style.width;
                    this.ctx.beginPath();
                    this.ctx.moveTo(points[0][0], points[0][1]);
                    for (let i = 1; i < points.length; i++) {
                        this.ctx.lineTo(points[i][0], points[i][1]);
                    }
                    this.ctx.stroke();
                }
            }

            drawGeometryWay(points, isClosed, isSelected, isMultiSelected) {
                const color = isSelected ? 'red' : (isMultiSelected ? 'yellow' : 'black');
                const width = (isSelected || isMultiSelected) ? 3 : 1;
                
                this.ctx.strokeStyle = color;
                this.ctx.lineWidth = width;
                this.ctx.fillStyle = 'transparent';
                
                if (isClosed && points.length >= 3) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(points[0][0], points[0][1]);
                    for (let i = 1; i < points.length; i++) {
                        this.ctx.lineTo(points[i][0], points[i][1]);
                    }
                    this.ctx.closePath();
                    this.ctx.stroke();
                } else {
                    this.ctx.beginPath();
                    this.ctx.moveTo(points[0][0], points[0][1]);
                    for (let i = 1; i < points.length; i++) {
                        this.ctx.lineTo(points[i][0], points[i][1]);
                    }
                    this.ctx.stroke();
                }
            }

            drawWayLabel(points, name, wayId) {
                const nameLabel = this.getNameLabel(name);
                if (!nameLabel) return;
                
                let centerX = 0, centerY = 0;
                for (const [x, y] of points) {
                    centerX += x;
                    centerY += y;
                }
                centerX /= points.length;
                centerY /= points.length;
                
                this.ctx.fillStyle = 'darkblue';
                this.ctx.font = 'bold 10px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(nameLabel, centerX, centerY);
            }

            drawNodeLabel(canvasX, canvasY, name) {
                const nameLabel = this.getNameLabel(name);
                if (!nameLabel) return;
                
                this.ctx.fillStyle = 'darkgreen';
                this.ctx.font = 'bold 9px Arial';
                this.ctx.textAlign = 'left';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText(nameLabel, canvasX + 15, canvasY - 10);
            }

            getNameLabel(name) {
                if (!name) return null;
                
                let chineseChars = '';
                for (const char of name) {
                    if (char >= '\u4e00' && char <= '\u9fff') {
                        chineseChars += char;
                    }
                }
                
                return chineseChars || name;
            }

            getBuildingStyle(tags) {
                if (!tags.building) return null;
                
                const buildingColor = this.getBuildingColor(tags);
                return { fill: buildingColor, outline: '#000000', width: 2 };
            }

            getLandscapeStyle(tags) {
                const landuse = tags.landuse;
                const natural = tags.natural;
                const leisure = tags.leisure;
                
                if (landuse === 'grass' || leisure === 'park' || leisure === 'garden') {
                    return { fill: '#90EE90', outline: '#228B22', width: 1 };
                } else if (natural === 'forest' || natural === 'wood' || landuse === 'forest') {
                    return { fill: '#228B22', outline: '#006400', width: 1 };
                } else if (landuse === 'farmland' || landuse === 'meadow') {
                    return { fill: '#ADFF2F', outline: '#32CD32', width: 1 };
                } else if (natural === 'water' || landuse === 'reservoir') {
                    return { fill: '#4169E1', outline: '#000080', width: 1 };
                } else if (landuse === 'residential') {
                    return { fill: '#FFE4B5', outline: '#8B4513', width: 1 };
                } else if (landuse === 'commercial') {
                    return { fill: '#DDA0DD', outline: '#800080', width: 1 };
                } else if (landuse === 'industrial') {
                    return { fill: '#D3D3D3', outline: '#696969', width: 1 };
                }
                
                return null;
            }

            getWayStyle(tags) {
                if (tags.highway) {
                    const styles = {
                        'motorway': { fill: '#FF6B6B', width: 6 },
                        'trunk': { fill: '#FF6B6B', width: 6 },
                        'primary': { fill: '#4ECDC4', width: 4 },
                        'secondary': { fill: '#4ECDC4', width: 4 },
                        'residential': { fill: '#45B7D1', width: 2 },
                        'tertiary': { fill: '#45B7D1', width: 2 },
                        'footway': { fill: '#96CEB4', width: 1 }
                    };
                    return styles[tags.highway] || { fill: '#333333', width: 2 };
                } else if (tags.waterway) {
                    return { fill: '#74C0FC', width: 3 };
                } else if (tags.railway) {
                    return { fill: '#000000', width: 2 };
                }
                return { fill: '#666666', width: 1 };
            }

            drawBoxSelect() {
                if (this.boxSelecting && this.boxStart && this.boxCurrent) {
                    this.ctx.strokeStyle = 'blue';
                    this.ctx.lineWidth = 2;
                    this.ctx.setLineDash([5, 5]);
                    this.ctx.beginPath();
                    this.ctx.rect(
                        this.boxStart[0], this.boxStart[1],
                        this.boxCurrent[0] - this.boxStart[0],
                        this.boxCurrent[1] - this.boxStart[1]
                    );
                    this.ctx.stroke();
                    this.ctx.setLineDash([]);
                }
            }

            drawMeasurement() {
                if (this.measurePoints.length < 2) return;
                
                for (let i = 0; i < this.measurePoints.length - 1; i++) {
                    const [x1, y1] = this.worldToCanvas(this.measurePoints[i][0], this.measurePoints[i][1]);
                    const [x2, y2] = this.worldToCanvas(this.measurePoints[i + 1][0], this.measurePoints[i + 1][1]);
                    
                    this.ctx.strokeStyle = 'red';
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.moveTo(x1, y1);
                    this.ctx.lineTo(x2, y2);
                    this.ctx.stroke();
                    
                    const midX = (x1 + x2) / 2;
                    const midY = (y1 + y2) / 2;
                    const distance = this.measureDistances[i];
                    
                    const distanceText = distance < 1000 ? `${distance.toFixed(1)}m` : `${(distance/1000).toFixed(2)}km`;
                    
                    this.ctx.fillStyle = 'white';
                    this.ctx.strokeStyle = 'red';
                    this.ctx.lineWidth = 1;
                    this.ctx.beginPath();
                    this.ctx.rect(midX - 25, midY - 8, 50, 16);
                    this.ctx.fill();
                    this.ctx.stroke();
                    
                    this.ctx.fillStyle = 'red';
                    this.ctx.font = 'bold 9px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(distanceText, midX, midY);
                }
                
                for (let i = 0; i < this.measurePoints.length; i++) {
                    const [x, y] = this.worldToCanvas(this.measurePoints[i][0], this.measurePoints[i][1]);
                    
                    this.ctx.fillStyle = 'red';
                    this.ctx.strokeStyle = 'white';
                    this.ctx.lineWidth = 2;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 5, 0, 2 * Math.PI);
                    this.ctx.fill();
                    this.ctx.stroke();
                    
                    this.ctx.fillStyle = 'red';
                    this.ctx.font = 'bold 10px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText((i + 1).toString(), x, y - 15);
                }
            }

            // 事件处理方法
            handleSelect(canvasX, canvasY, shiftPressed = false, ctrlPressed = false) {
                let minDist = Infinity;
                let closestNode = null;
                
                for (const [nodeId, nodeData] of this.nodes) {
                    const [nodeCanvasX, nodeCanvasY] = this.worldToCanvas(nodeData.lon, nodeData.lat);
                    const dist = Math.sqrt((canvasX - nodeCanvasX) ** 2 + (canvasY - nodeCanvasY) ** 2);
                    
                    if (dist < 15 && dist < minDist) {
                        minDist = dist;
                        closestNode = nodeId;
                    }
                }
                
                let closestWay = null;
                let minWayDist = Infinity;
                for (const [wayId, wayData] of this.ways) {
                    const nodeIds = wayData.nodes;
                    if (nodeIds.length >= 2) {
                        for (let i = 0; i < nodeIds.length - 1; i++) {
                            const node1Id = nodeIds[i];
                            const node2Id = nodeIds[i + 1];
                            
                            if (this.nodes.has(node1Id) && this.nodes.has(node2Id)) {
                                const [x1, y1] = this.worldToCanvas(this.nodes.get(node1Id).lon, this.nodes.get(node1Id).lat);
                                const [x2, y2] = this.worldToCanvas(this.nodes.get(node2Id).lon, this.nodes.get(node2Id).lat);
                                
                                const dist = this.pointToLineDistance(canvasX, canvasY, x1, y1, x2, y2);
                                if (dist < 10 && dist < minWayDist) {
                                    minWayDist = dist;
                                    closestWay = wayId;
                                }
                            }
                        }
                    }
                }
                
                if (closestNode && (!closestWay || minDist < minWayDist)) {
                    this.selectedNode = closestNode;
                    this.selectedWay = null;
                } else if (closestWay) {
                    const wayData = this.ways.get(closestWay);
                    const nodeIds = wayData.nodes;
                    const isPolygon = nodeIds.length >= 4 && nodeIds[0] === nodeIds[nodeIds.length - 1];
                    
                    if (isPolygon) {
                        if (shiftPressed) {
                            this.selectedWays.delete(closestWay);
                        } else if (ctrlPressed) {
                            this.selectedWays.add(closestWay);
                        } else {
                            this.selectedWay = closestWay;
                            this.selectedWays.clear();
                            this.selectedWays.add(closestWay);
                        }
                    } else {
                        this.selectedWay = closestWay;
                        this.selectedWays.clear();
                    }
                    
                    this.selectedNode = null;
                } else {
                    if (!shiftPressed && !ctrlPressed) {
                        this.selectedNode = null;
                        this.selectedWay = null;
                        this.selectedWays.clear();
                    }
                }
                
                this.updateSelectionInfo();
                this.updateMultiselectInfo();
                this.redraw();
            }

            pointToLineDistance(px, py, x1, y1, x2, y2) {
                const A = px - x1;
                const B = py - y1;
                const C = x2 - x1;
                const D = y2 - y1;
                
                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                
                if (lenSq === 0) {
                    return Math.sqrt(A * A + B * B);
                }
                
                const param = dot / lenSq;
                
                let xx, yy;
                if (param < 0) {
                    xx = x1;
                    yy = y1;
                } else if (param > 1) {
                    xx = x2;
                    yy = y2;
                } else {
                    xx = x1 + param * C;
                    yy = y1 + param * D;
                }
                
                const dx = px - xx;
                const dy = py - yy;
                return Math.sqrt(dx * dx + dy * dy);
            }

            startBoxSelect(x, y) {
                this.boxSelecting = true;
                this.boxStart = [x, y];
                this.boxCurrent = [x, y];
            }

            updateBoxSelect(x, y) {
                if (this.boxSelecting) {
                    this.boxCurrent = [x, y];
                    this.redraw();
                }
            }

            finishBoxSelect(x, y, shiftPressed = false, ctrlPressed = false) {
                if (!this.boxSelecting) return;
                
                this.boxSelecting = false;
                
                const x1 = this.boxStart[0];
                const y1 = this.boxStart[1];
                const x2 = x;
                const y2 = y;
                
                const minX = Math.min(x1, x2);
                const maxX = Math.max(x1, x2);
                const minY = Math.min(y1, y2);
                const maxY = Math.max(y1, y2);
                
                const selectedInBox = new Set();
                
                for (const [wayId, wayData] of this.ways) {
                    const nodeIds = wayData.nodes;
                    if (nodeIds.length >= 4 && nodeIds[0] === nodeIds[nodeIds.length - 1]) {
                        let allInBox = true;
                        for (const nodeId of nodeIds) {
                            if (this.nodes.has(nodeId)) {
                                const node = this.nodes.get(nodeId);
                                const [canvasX, canvasY] = this.worldToCanvas(node.lon, node.lat);
                                if (!(minX <= canvasX && canvasX <= maxX && minY <= canvasY && canvasY <= maxY)) {
                                    allInBox = false;
                                    break;
                                }
                            }
                        }
                        
                        if (allInBox) {
                            selectedInBox.add(wayId);
                        }
                    }
                }
                
                if (shiftPressed) {
                    for (const wayId of selectedInBox) {
                        this.selectedWays.delete(wayId);
                    }
                } else if (ctrlPressed) {
                    for (const wayId of selectedInBox) {
                        this.selectedWays.add(wayId);
                    }
                } else {
                    this.selectedWays = selectedInBox;
                }
                
                this.updateMultiselectInfo();
                this.redraw();
            }

            addNode(worldX, worldY) {
                const nodeId = this.nodes.size > 0 ? Math.max(...this.nodes.keys()) + 1 : 1;
                const nodeData = {
                    lat: worldY,
                    lon: worldX,
                    tags: {}
                };
                
                const command = new AddObjectCommand(this, 'node', nodeId, nodeData);
                this.executeCommand(command);
                this.redraw();
            }

            handleWayCreation(canvasX, canvasY) {
                const closestNode = this.findClosestNode(canvasX, canvasY);
                
                if (closestNode) {
                    if (!this.creatingWay.includes(closestNode)) {
                        this.creatingWay.push(closestNode);
                    }
                } else {
                    const [worldX, worldY] = this.canvasToWorld(canvasX, canvasY);
                    
                    if (this.gridSettings.snapToGrid) {
                        const [snapX, snapY] = this.snapToGrid(worldX, worldY);
                        worldX = snapX;
                        worldY = snapY;
                    }
                    
                    const nodeId = this.nodes.size > 0 ? Math.max(...this.nodes.keys()) + 1 : 1;
                    const nodeData = {
                        lat: worldY,
                        lon: worldX,
                        tags: {}
                    };
                    
                    const command = new AddObjectCommand(this, 'node', nodeId, nodeData);
                    this.executeCommand(command);
                    this.creatingWay.push(nodeId);
                }
                
                this.updateCreateStatus();
                this.redraw();
            }

            handlePolygonCreation(canvasX, canvasY) {
                this.handleWayCreation(canvasX, canvasY);
            }

            findClosestNode(canvasX, canvasY, maxDistance = 15) {
                let minDist = Infinity;
                let closestNode = null;
                
                for (const [nodeId, nodeData] of this.nodes) {
                    const [nodeCanvasX, nodeCanvasY] = this.worldToCanvas(nodeData.lon, nodeData.lat);
                    const dist = Math.sqrt((canvasX - nodeCanvasX) ** 2 + (canvasY - nodeCanvasY) ** 2);
                    
                    if (dist < maxDistance && dist < minDist) {
                        minDist = dist;
                        closestNode = nodeId;
                    }
                }
                
                return closestNode;
            }

            finishCreation() {
                if (this.creatingWay.length < 2) return;
                
                const wayId = this.ways.size > 0 ? Math.max(...this.ways.keys()) + 1 : 1;
                
                let wayData;
                if (this.mode === "add_polygon" && this.creatingWay.length >= 3) {
                    if (this.creatingWay[0] !== this.creatingWay[this.creatingWay.length - 1]) {
                        this.creatingWay.push(this.creatingWay[0]);
                    }
                    wayData = {
                        nodes: [...this.creatingWay],
                        tags: { area: 'yes' }
                    };
                } else {
                    wayData = {
                        nodes: [...this.creatingWay],
                        tags: {}
                    };
                }
                
                const command = new AddObjectCommand(this, 'way', wayId, wayData);
                this.executeCommand(command);
                
                this.creatingWay = [];
                this.updateCreateStatus();
                this.redraw();
            }

            cancelCreation() {
                this.creatingWay = [];
                this.boxSelecting = false;
                this.updateCreateStatus();
                this.redraw();
            }

            moveSelectedNode(dx, dy) {
                if (this.selectedNode && this.nodes.has(this.selectedNode)) {
                    const worldDx = dx / this.scale;
                    const worldDy = -dy / this.scale;
                    
                    const rad = -this.rotation * Math.PI / 180;
                    const cosR = Math.cos(rad);
                    const sinR = Math.sin(rad);
                    
                    const rotatedDx = worldDx * cosR - worldDy * sinR;
                    const rotatedDy = worldDx * sinR + worldDy * cosR;
                    
                    const node = this.nodes.get(this.selectedNode);
                    let newLon = node.lon + rotatedDx;
                    let newLat = node.lat + rotatedDy;
                    
                    if (this.gridSettings.snapToGrid) {
                        [newLon, newLat] = this.snapToGrid(newLon, newLat);
                    }
                    
                    node.lon = newLon;
                    node.lat = newLat;
                    
                    this.redraw();
                    this.updateSelectionInfo();
                }
            }

            calculateDistance(point1, point2) {
                const [lon1, lat1] = point1;
                const [lon2, lat2] = point2;
                
                const [x1, y1] = this.coordSystem.geographicToScene(lon1, lat1);
                const [x2, y2] = this.coordSystem.geographicToScene(lon2, lat2);
                
                return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
            }

            addMeasurePoint(worldX, worldY) {
                this.measurePoints.push([worldX, worldY]);
                
                if (this.measurePoints.length > 1) {
                    const distance = this.calculateDistance(
                        this.measurePoints[this.measurePoints.length - 2],
                        this.measurePoints[this.measurePoints.length - 1]
                    );
                    this.measureDistances.push(distance);
                    
                    const totalDistance = this.measureDistances.reduce((sum, d) => sum + d, 0);
                    
                    const measureLabel = document.getElementById('measureLabel');
                    if (totalDistance < 1000) {
                        measureLabel.textContent = `距离: ${totalDistance.toFixed(1)}m`;
                    } else {
                        measureLabel.textContent = `距离: ${(totalDistance / 1000).toFixed(2)}km`;
                    }
                }
                
                this.redraw();
            }

            clearMeasurement() {
                this.measurePoints = [];
                this.measureDistances = [];
                document.getElementById('measureLabel').textContent = "距离: 0m";
                this.redraw();
            }

            // 选择操作
            selectAllPolygons() {
                this.selectedWays.clear();
                for (const [wayId, wayData] of this.ways) {
                    const nodeIds = wayData.nodes;
                    if (nodeIds.length >= 4 && nodeIds[0] === nodeIds[nodeIds.length - 1]) {
                        this.selectedWays.add(wayId);
                    }
                }
                
                this.updateMultiselectInfo();
                this.redraw();
            }

            clearSelection() {
                this.selectedNode = null;
                this.selectedWay = null;
                this.selectedWays.clear();
                this.updateMultiselectInfo();
                this.updateSelectionInfo();
                this.redraw();
            }

            deleteSelected() {
                if (this.selectedNode) {
                    const nodeData = structuredClone(this.nodes.get(this.selectedNode));
                    const affectedWays = {};
                    
                    for (const [wayId, wayData] of this.ways) {
                        if (wayData.nodes.includes(this.selectedNode)) {
                            affectedWays[wayId] = structuredClone(wayData);
                        }
                    }
                    
                    const finalAffectedWays = {};
                    for (const [wayId, wayData] of Object.entries(affectedWays)) {
                        const remainingNodes = wayData.nodes.filter(n => n !== this.selectedNode);
                        if (remainingNodes.length < 2) {
                            finalAffectedWays[wayId] = wayData;
                        }
                    }
                    
                    const command = new DeleteObjectCommand(this, 'node', this.selectedNode, nodeData, finalAffectedWays);
                    this.executeCommand(command);
                    
                    this.selectedNode = null;
                    
                } else if (this.selectedWay) {
                    const wayData = structuredClone(this.ways.get(this.selectedWay));
                    const command = new DeleteObjectCommand(this, 'way', this.selectedWay, wayData);
                    this.executeCommand(command);
                    
                    this.selectedWay = null;
                } else if (this.selectedWays.size > 0) {
                    for (const wayId of this.selectedWays) {
                        const wayData = structuredClone(this.ways.get(wayId));
                        const command = new DeleteObjectCommand(this, 'way', wayId, wayData);
                        this.executeCommand(command);
                    }
                    
                    this.selectedWays.clear();
                } else {
                    alert("请先选择一个对象！");
                    return;
                }
                
                this.redraw();
                this.updateSelectionInfo();
                this.updateMultiselectInfo();
            }

            updateSelectionInfo() {
                const infoText = document.getElementById('infoText');
                let info = '';
                
                if (this.selectedNode) {
                    const node = this.nodes.get(this.selectedNode);
                    info = `节点 ID: ${this.selectedNode}\n`;
                    
                    if (this.coordSystem.coordType === "geographic") {
                        info += `经度: ${node.lon.toFixed(6)}\n`;
                        info += `纬度: ${node.lat.toFixed(6)}\n`;
                    } else {
                        const [sceneX, sceneY] = this.coordSystem.geographicToScene(node.lon, node.lat);
                        info += `X: ${sceneX.toFixed(2)} 米\n`;
                        info += `Y: ${sceneY.toFixed(2)} 米\n`;
                    }
                    
                    info += node.modified ? "状态: 已修改\n" : "状态: 原始\n";
                    
                    const tags = node.tags || {};
                    if (Object.keys(tags).length > 0) {
                        info += "\n标签:\n";
                        for (const [key, value] of Object.entries(tags)) {
                            info += `  ${key} = ${value}\n`;
                        }
                    } else {
                        info += "\n无标签";
                    }
                    
                } else if (this.selectedWay) {
                    const way = this.ways.get(this.selectedWay);
                    info = `路径 ID: ${this.selectedWay}\n`;
                    info += `节点数: ${way.nodes.length}\n`;
                    info += `节点: ${way.nodes.join(', ')}\n`;
                    
                    const tags = way.tags || {};
                    if (Object.keys(tags).length > 0) {
                        info += "\n标签:\n";
                        for (const [key, value] of Object.entries(tags)) {
                            info += `  ${key} = ${value}\n`;
                        }
                        
                        if (tags.building) {
                            const height = this.getBuildingHeight(tags);
                            const color = this.getBuildingColor(tags);
                            info += `\n建筑高度: ${height}米\n`;
                            info += `建筑颜色: ${color}\n`;
                        }
                    } else {
                        info += "\n无标签";
                    }
                    
                } else if (this.selectedWays.size > 0) {
                    info = `多选 - 共选择了 ${this.selectedWays.size} 个多边形:\n\n`;
                    let i = 0;
                    for (const wayId of Array.from(this.selectedWays).sort((a, b) => a - b)) {
                        const way = this.ways.get(wayId);
                        info += `多边形 ${i + 1} (ID: ${wayId}):\n`;
                        info += `  节点数: ${way.nodes.length}\n`;
                        
                        const tags = way.tags || {};
                        if (Object.keys(tags).length > 0) {
                            const mainTags = Object.entries(tags).slice(0, 3);
                            const tagStrings = mainTags.map(([k, v]) => `${k}=${v}`);
                            info += `  主要标签: {${tagStrings.join(', ')}}\n`;
                            
                            if (tags.building) {
                                const height = this.getBuildingHeight(tags);
                                const color = this.getBuildingColor(tags);
                                info += `  高度: ${height}米\n`;
                                info += `  颜色: ${color}\n`;
                            }
                        }
                        
                        info += "\n";
                        i++;
                    }
                }
                
                infoText.textContent = info;
            }

            // 视图控制
            resetView() {
                this.scale = 100000;
                this.centerX = 0;
                this.centerY = 0;
                this.rotation = 0;
                this.redraw();
            }

            fitToWindow() {
                if (this.nodes.size === 0) return;
                
                const lons = Array.from(this.nodes.values()).map(node => node.lon);
                const lats = Array.from(this.nodes.values()).map(node => node.lat);
                
                const minLon = Math.min(...lons);
                const maxLon = Math.max(...lons);
                const minLat = Math.min(...lats);
                const maxLat = Math.max(...lats);
                
                this.centerX = (minLon + maxLon) / 2;
                this.centerY = (minLat + maxLat) / 2;
                
                const dataWidth = maxLon - minLon;
                const dataHeight = maxLat - minLat;
                
                if (dataWidth > 0 && dataHeight > 0) {
                    const scaleX = this.canvas.width * 0.8 / dataWidth;
                    const scaleY = this.canvas.height * 0.8 / dataHeight;
                    this.scale = Math.min(scaleX, scaleY);
                    this.scale = Math.max(1000, Math.min(1000000, this.scale));
                }
                
                this.rotation = 0;
                this.redraw();
            }

            rotateView(angle) {
                this.rotation += angle;
                this.rotation = this.rotation % 360;
                this.redraw();
            }

            // 坐标系统设置
            setSceneOrigin() {
                const dialog = this.createDialog('设置场景坐标系原点', 400, 200);
                
                dialog.innerHTML = `
                    <h3>设置场景坐标系原点</h3>
                    <div class="form-row">
                        <label>经度:</label>
                        <input type="number" id="originLon" value="${this.coordSystem.sceneOriginLon}" step="0.000001">
                    </div>
                    <div class="form-row">
                        <label>纬度:</label>
                        <input type="number" id="originLat" value="${this.coordSystem.sceneOriginLat}" step="0.000001">
                    </div>
                    <div class="dialog-buttons">
                        <button onclick="editor.applySceneOrigin()">确定</button>
                        <button onclick="editor.closeDialog()">取消</button>
                    </div>
                `;
            }

            applySceneOrigin() {
                const lonInput = document.getElementById('originLon');
                const latInput = document.getElementById('originLat');
                
                try {
                    this.coordSystem.sceneOriginLon = parseFloat(lonInput.value);
                    this.coordSystem.sceneOriginLat = parseFloat(latInput.value);
                    this.redraw();
                    this.closeDialog();
                } catch (error) {
                    alert('请输入有效的数值！');
                }
            }

            useCurrentCenterAsOrigin() {
                this.coordSystem.sceneOriginLon = this.centerX;
                this.coordSystem.sceneOriginLat = this.centerY;
                this.redraw();
                alert(`场景坐标系原点已设置为:\n经度: ${this.centerX.toFixed(6)}\n纬度: ${this.centerY.toFixed(6)}`);
            }

            // 标签编辑
            editTags() {
                if (this.selectedNode) {
                    const node = this.nodes.get(this.selectedNode);
                    const oldTags = structuredClone(node.tags || {});
                    this.showTagEditor('node', this.selectedNode, oldTags);
                } else if (this.selectedWay) {
                    const way = this.ways.get(this.selectedWay);
                    const oldTags = structuredClone(way.tags || {});
                    this.showTagEditor('way', this.selectedWay, oldTags);
                } else {
                    alert("请先选择一个对象！");
                }
            }

            showTagEditor(objType, objId, tags) {
                const dialog = this.createDialog('编辑标签', 500, 400);
                
                let tagRows = '';
                for (const [key, value] of Object.entries(tags)) {
                    tagRows += `
                        <tr class="tag-row">
                            <td>${key}</td>
                            <td>${value}</td>
                        </tr>
                    `;
                }
                
                dialog.innerHTML = `
                    <h3>编辑标签</h3>
                    <table class="tag-table">
                        <thead>
                            <tr>
                                <th>键</th>
                                <th>值</th>
                            </tr>
                        </thead>
                        <tbody id="tagTableBody">
                            ${tagRows}
                        </tbody>
                    </table>
                    <div class="dialog-buttons">
                        <button onclick="editor.addTag()">添加</button>
                        <button onclick="editor.editSelectedTag()">编辑</button>
                        <button onclick="editor.deleteSelectedTag()">删除</button>
                        <button onclick="editor.applyTagChanges('${objType}', ${objId})">确定</button>
                        <button onclick="editor.closeDialog()">取消</button>
                    </div>
                `;
                
                const rows = dialog.querySelectorAll('.tag-row');
                rows.forEach(row => {
                    row.addEventListener('click', () => {
                        rows.forEach(r => r.classList.remove('selected'));
                        row.classList.add('selected');
                    });
                });
            }

            addTag() {
                const key = prompt('请输入键:');
                if (key) {
                    const value = prompt('请输入值:');
                    if (value !== null) {
                        const tbody = document.getElementById('tagTableBody');
                        const row = document.createElement('tr');
                        row.className = 'tag-row';
                        row.innerHTML = `<td>${key}</td><td>${value}</td>`;
                        row.addEventListener('click', () => {
                            document.querySelectorAll('.tag-row').forEach(r => r.classList.remove('selected'));
                            row.classList.add('selected');
                        });
                        tbody.appendChild(row);
                    }
                }
            }

            editSelectedTag() {
                const selectedRow = document.querySelector('.tag-row.selected');
                if (selectedRow) {
                    const cells = selectedRow.querySelectorAll('td');
                    const oldKey = cells[0].textContent;
                    const oldValue = cells[1].textContent;
                    
                    const key = prompt('请输入键:', oldKey);
                    if (key !== null) {
                        const value = prompt('请输入值:', oldValue);
                        if (value !== null) {
                            cells[0].textContent = key;
                            cells[1].textContent = value;
                        }
                    }
                }
            }

            deleteSelectedTag() {
                const selectedRow = document.querySelector('.tag-row.selected');
                if (selectedRow) {
                    selectedRow.remove();
                }
            }

            applyTagChanges(objType, objId) {
                const rows = document.querySelectorAll('#tagTableBody .tag-row');
                const newTags = {};
                
                rows.forEach(row => {
                    const cells = row.querySelectorAll('td');
                    const key = cells[0].textContent;
                    const value = cells[1].textContent;
                    newTags[key] = value;
                });
                
                let oldTags;
                if (objType === 'node') {
                    oldTags = structuredClone(this.nodes.get(objId).tags || {});
                } else {
                    oldTags = structuredClone(this.ways.get(objId).tags || {});
                }
                
                const command = new ModifyTagsCommand(this, objType, objId, oldTags, newTags);
                this.executeCommand(command);
                
                this.updateSelectionInfo();
                this.redraw();
                this.closeDialog();
            }

            // 地图校正
            showMapCalibration() {
                const dialog = this.createDialog('地图校正', 700, 500);
                
                let nodeRows = '';
                for (const [nodeId, nodeData] of this.nodes) {
                    const [sceneX, sceneY] = this.coordSystem.geographicToScene(nodeData.lon, nodeData.lat);
                    const status = nodeData.modified ? '已修改' : '原始';
                    const tags = nodeData.tags || {};
                    const tagStr = Object.entries(tags).slice(0, 2).map(([k, v]) => `${k}=${v}`).join(', ');
                    
                    nodeRows += `
                        <tr class="node-row" data-node-id="${nodeId}">
                            <td>${nodeId}</td>
                            <td>${nodeData.lon.toFixed(6)}</td>
                            <td>${nodeData.lat.toFixed(6)}</td>
                            <td>${sceneX.toFixed(2)}</td>
                            <td>${sceneY.toFixed(2)}</td>
                            <td>${status}</td>
                            <td>${tagStr}</td>
                        </tr>
                    `;
                }
                
                dialog.innerHTML = `
                    <h3>地图校正 - 修改节点坐标</h3>
                    <div style="height: 200px; overflow-y: auto; border: 1px solid #ccc; margin: 10px 0;">
                        <table class="tag-table">
                            <thead>
                                <tr>
                                    <th>ID</th>
                                    <th>经度</th>
                                    <th>纬度</th>
                                    <th>X(米)</th>
                                    <th>Y(米)</th>
                                    <th>状态</th>
                                    <th>标签</th>
                                </tr>
                            </thead>
                            <tbody id="nodeTableBody">
                                ${nodeRows}
                            </tbody>
                        </table>
                    </div>
                    
                    <div class="form-row">
                        <label>坐标类型:</label>
                        <input type="radio" id="coordTypeGeo" name="coordType" value="geographic" checked>
                        <label for="coordTypeGeo">经纬度</label>
                        <input type="radio" id="coordTypeScene" name="coordType" value="scene">
                        <label for="coordTypeScene">场景坐标(米)</label>
                    </div>
                    
                    <div id="geoInputs">
                        <div class="form-row">
                            <label>经度:</label>
                            <input type="number" id="editLon" step="0.000001">
                            <label>纬度:</label>
                            <input type="number" id="editLat" step="0.000001">
                        </div>
                    </div>
                    
                    <div id="sceneInputs" class="hidden">
                        <div class="form-row">
                            <label>X(米):</label>
                            <input type="number" id="editX" step="0.01">
                            <label>Y(米):</label>
                            <input type="number" id="editY" step="0.01">
                        </div>
                    </div>
                    
                    <div class="dialog-buttons">
                        <button onclick="editor.applyCalibrationChanges()">应用修改</button>
                        <button onclick="editor.loadSelectedNodeToCalibration()">获取当前选中</button>
                        <button onclick="editor.resetModifications()">重置修改状态</button>
                        <button onclick="editor.closeDialog()">关闭</button>
                    </div>
                `;
                
                const rows = dialog.querySelectorAll('.node-row');
                rows.forEach(row => {
                    row.addEventListener('click', () => {
                        rows.forEach(r => r.classList.remove('selected'));
                        row.classList.add('selected');
                        
                        const nodeId = parseInt(row.dataset.nodeId);
                        const node = this.nodes.get(nodeId);
                        
                        if (document.getElementById('coordTypeGeo').checked) {
                            document.getElementById('editLon').value = node.lon.toFixed(6);
                            document.getElementById('editLat').value = node.lat.toFixed(6);
                        } else {
                            const [sceneX, sceneY] = this.coordSystem.geographicToScene(node.lon, node.lat);
                            document.getElementById('editX').value = sceneX.toFixed(2);
                            document.getElementById('editY').value = sceneY.toFixed(2);
                        }
                    });
                });
                
                document.getElementById('coordTypeGeo').addEventListener('change', () => {
                    document.getElementById('geoInputs').classList.remove('hidden');
                    document.getElementById('sceneInputs').classList.add('hidden');
                });
                
                document.getElementById('coordTypeScene').addEventListener('change', () => {
                    document.getElementById('geoInputs').classList.add('hidden');
                    document.getElementById('sceneInputs').classList.remove('hidden');
                });
            }

            loadSelectedNodeToCalibration() {
                if (this.selectedNode) {
                    const node = this.nodes.get(this.selectedNode);
                    
                    if (document.getElementById('coordTypeGeo').checked) {
                        document.getElementById('editLon').value = node.lon.toFixed(6);
                        document.getElementById('editLat').value = node.lat.toFixed(6);
                    } else {
                        const [sceneX, sceneY] = this.coordSystem.geographicToScene(node.lon, node.lat);
                        document.getElementById('editX').value = sceneX.toFixed(2);
                        document.getElementById('editY').value = sceneY.toFixed(2);
                    }
                    
                    const rows = document.querySelectorAll('.node-row');
                    rows.forEach(row => {
                        row.classList.remove('selected');
                        if (parseInt(row.dataset.nodeId) === this.selectedNode) {
                            row.classList.add('selected');
                        }
                    });
                } else {
                    alert("请先在地图上选择一个节点！");
                }
            }

            applyCalibrationChanges() {
                const selectedRow = document.querySelector('.node-row.selected');
                if (!selectedRow) {
                    alert("请先选择一个节点！");
                    return;
                }
                
                const nodeId = parseInt(selectedRow.dataset.nodeId);
                
                try {
                    let newLon, newLat;
                    
                    if (document.getElementById('coordTypeGeo').checked) {
                        newLon = parseFloat(document.getElementById('editLon').value);
                        newLat = parseFloat(document.getElementById('editLat').value);
                    } else {
                        const newX = parseFloat(document.getElementById('editX').value);
                        const newY = parseFloat(document.getElementById('editY').value);
                        [newLon, newLat] = this.coordSystem.sceneToGeographic(newX, newY);
                    }
                    
                    const node = this.nodes.get(nodeId);
                    const oldPos = [node.lon, node.lat];
                    const newPos = [newLon, newLat];
                    
                    const command = new MoveNodeCommand(this, nodeId, oldPos, newPos);
                    this.executeCommand(command);
                    
                    node.modified = true;
                    
                    this.redraw();
                    this.updateSelectionInfo();
                    
                    const coordType = document.getElementById('coordTypeGeo').checked ? "经纬度" : "场景坐标";
                    alert(`节点 ${nodeId} ${coordType}已更新！`);
                    
                } catch (error) {
                    alert("请输入有效的坐标数值！");
                }
            }

            resetModifications() {
                if (confirm("确定要重置所有节点的修改状态吗？")) {
                    for (const nodeData of this.nodes.values()) {
                        delete nodeData.modified;
                    }
                    this.redraw();
                    alert("所有节点修改状态已重置！");
                }
            }

            // 网格控制面板
            showGridControlPanel() {
                const dialog = this.createDialog('网格控制面板', 400, 500);
                
                dialog.innerHTML = `
                    <h3>网格控制面板</h3>
                    
                    <div class="form-row">
                        <label>显示设置:</label>
                    </div>
                    <div class="form-row">
                        <input type="checkbox" id="showGridCheck" ${this.gridSettings.showGrid ? 'checked' : ''}>
                        <label for="showGridCheck">显示网格</label>
                    </div>
                    <div class="form-row">
                        <input type="checkbox" id="showCoordsCheck" ${this.gridSettings.showCoordinates ? 'checked' : ''}>
                        <label for="showCoordsCheck">显示网格坐标</label>
                    </div>
                    <div class="form-row">
                        <input type="checkbox" id="snapToGridCheck" ${this.gridSettings.snapToGrid ? 'checked' : ''}>
                        <label for="snapToGridCheck">吸附到网格</label>
                    </div>
                    
                    <div class="form-row">
                        <label>网格原点:</label>
                    </div>
                    <div class="form-row">
                        <label>经度:</label>
                        <input type="number" id="gridOriginX" value="${this.gridSettings.originX}" step="0.000001">
                    </div>
                    <div class="form-row">
                        <label>纬度:</label>
                        <input type="number" id="gridOriginY" value="${this.gridSettings.originY}" step="0.000001">
                    </div>
                    
                    <div class="form-row">
                        <label>网格大小:</label>
                        <select id="gridSizeSelect">
                            <option value="1" ${this.gridSettings.gridSizeMeters === 1 ? 'selected' : ''}>1米</option>
                            <option value="5" ${this.gridSettings.gridSizeMeters === 5 ? 'selected' : ''}>5米</option>
                            <option value="10" ${this.gridSettings.gridSizeMeters === 10 ? 'selected' : ''}>10米</option>
                            <option value="25" ${this.gridSettings.gridSizeMeters === 25 ? 'selected' : ''}>25米</option>
                            <option value="50" ${this.gridSettings.gridSizeMeters === 50 ? 'selected' : ''}>50米</option>
                            <option value="100" ${this.gridSettings.gridSizeMeters === 100 ? 'selected' : ''}>100米</option>
                            <option value="250" ${this.gridSettings.gridSizeMeters === 250 ? 'selected' : ''}>250米</option>
                            <option value="500" ${this.gridSettings.gridSizeMeters === 500 ? 'selected' : ''}>500米</option>
                            <option value="1000" ${this.gridSettings.gridSizeMeters === 1000 ? 'selected' : ''}>1000米</option>
                        </select>
                    </div>
                    
                    <div class="form-row">
                        <label>网格颜色:</label>
                        <select id="gridColorSelect">
                            <option value="lightgray" ${this.gridSettings.gridColor === 'lightgray' ? 'selected' : ''}>浅灰</option>
                            <option value="gray" ${this.gridSettings.gridColor === 'gray' ? 'selected' : ''}>灰色</option>
                            <option value="darkgray" ${this.gridSettings.gridColor === 'darkgray' ? 'selected' : ''}>深灰</option>
                            <option value="blue" ${this.gridSettings.gridColor === 'blue' ? 'selected' : ''}>蓝色</option>
                            <option value="green" ${this.gridSettings.gridColor === 'green' ? 'selected' : ''}>绿色</option>
                            <option value="black" ${this.gridSettings.gridColor === 'black' ? 'selected' : ''}>黑色</option>
                        </select>
                    </div>
                    
                    <div class="form-row">
                        <label>坐标轴颜色:</label>
                        <select id="axisColorSelect">
                            <option value="red" ${this.gridSettings.axisColor === 'red' ? 'selected' : ''}>红色</option>
                            <option value="blue" ${this.gridSettings.axisColor === 'blue' ? 'selected' : ''}>蓝色</option>
                            <option value="green" ${this.gridSettings.axisColor === 'green' ? 'selected' : ''}>绿色</option>
                            <option value="orange" ${this.gridSettings.axisColor === 'orange' ? 'selected' : ''}>橙色</option>
                            <option value="purple" ${this.gridSettings.axisColor === 'purple' ? 'selected' : ''}>紫色</option>
                            <option value="black" ${this.gridSettings.axisColor === 'black' ? 'selected' : ''}>黑色</option>
                        </select>
                    </div>
                    
                    <div class="form-row">
                        <button onclick="editor.resetGridToOrigin()">重置到原点</button>
                        <button onclick="editor.resetGridToDataCenter()">重置到数据中心</button>
                    </div>
                    
                    <div class="dialog-buttons">
                        <button onclick="editor.applyGridSettings()">应用</button>
                        <button onclick="editor.closeDialog()">关闭</button>
                    </div>
                `;
                
                const inputs = dialog.querySelectorAll('input, select');
                inputs.forEach(input => {
                    input.addEventListener('change', () => this.updateGridSettings());
                });
            }

            updateGridSettings() {
                this.gridSettings.showGrid = document.getElementById('showGridCheck').checked;
                this.gridSettings.showCoordinates = document.getElementById('showCoordsCheck').checked;
                this.gridSettings.snapToGrid = document.getElementById('snapToGridCheck').checked;
                this.gridSettings.originX = parseFloat(document.getElementById('gridOriginX').value);
                this.gridSettings.originY = parseFloat(document.getElementById('gridOriginY').value);
                this.gridSettings.gridSizeMeters = parseInt(document.getElementById('gridSizeSelect').value);
                this.gridSettings.gridColor = document.getElementById('gridColorSelect').value;
                this.gridSettings.axisColor = document.getElementById('axisColorSelect').value;
                
                this.updateGridStatus();
                this.redraw();
            }

            resetGridToOrigin() {
                document.getElementById('gridOriginX').value = 0;
                document.getElementById('gridOriginY').value = 0;
                this.updateGridSettings();
            }

            resetGridToDataCenter() {
                if (this.nodes.size > 0) {
                    const lons = Array.from(this.nodes.values()).map(node => node.lon);
                    const lats = Array.from(this.nodes.values()).map(node => node.lat);
                    const centerLon = lons.reduce((sum, lon) => sum + lon, 0) / lons.length;
                    const centerLat = lats.reduce((sum, lat) => sum + lat, 0) / lats.length;
                    
                    document.getElementById('gridOriginX').value = centerLon.toFixed(6);
                    document.getElementById('gridOriginY').value = centerLat.toFixed(6);
                    this.updateGridSettings();
                }
            }

            applyGridSettings() {
                this.updateGridSettings();
                alert("网格设置已应用！");
            }

            // 文件操作
            importOSM() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.osm,.xml';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            try {
                                this.loadOSMData(e.target.result);
                                this.fitToWindow();
                                this.undoStack = [];
                                this.redoStack = [];
                                this.updateUndoRedoButtons();
                                alert("OSM文件导入成功！");
                            } catch (error) {
                                alert(`导入失败: ${error.message}`);
                            }
                        };
                        reader.readAsText(file);
                    }
                };
                input.click();
            }

            loadOSMData(xmlText) {
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
                
                this.nodes.clear();
                this.ways.clear();
                this.relations.clear();
                
                const nodeElements = xmlDoc.querySelectorAll('node');
                nodeElements.forEach(nodeElem => {
                    const nodeId = parseInt(nodeElem.getAttribute('id'));
                    const lat = parseFloat(nodeElem.getAttribute('lat'));
                    const lon = parseFloat(nodeElem.getAttribute('lon'));
                    
                    const tags = {};
                    const tagElements = nodeElem.querySelectorAll('tag');
                    tagElements.forEach(tagElem => {
                        const key = tagElem.getAttribute('k');
                        const value = tagElem.getAttribute('v');
                        tags[key] = value;
                    });
                    
                    this.nodes.set(nodeId, {
                        lat: lat,
                        lon: lon,
                        tags: tags
                    });
                });
                
                const wayElements = xmlDoc.querySelectorAll('way');
                wayElements.forEach(wayElem => {
                    const wayId = parseInt(wayElem.getAttribute('id'));
                    const nodes = [];
                    const tags = {};
                    
                    const ndElements = wayElem.querySelectorAll('nd');
                    ndElements.forEach(ndElem => {
                        const nodeRef = parseInt(ndElem.getAttribute('ref'));
                        if (this.nodes.has(nodeRef)) {
                            nodes.push(nodeRef);
                        }
                    });
                    
                    const tagElements = wayElem.querySelectorAll('tag');
                    tagElements.forEach(tagElem => {
                        const key = tagElem.getAttribute('k');
                        const value = tagElem.getAttribute('v');
                        tags[key] = value;
                    });
                    
                    if (nodes.length > 0) {
                        this.ways.set(wayId, {
                            nodes: nodes,
                            tags: tags
                        });
                    }
                });
            }

            exportOSM() {
                if (this.nodes.size === 0) {
                    alert("没有数据可导出！");
                    return;
                }
                
                const xmlText = this.generateOSMXML();
                const blob = new Blob([xmlText], { type: 'text/xml' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = 'export.osm';
                a.click();
                
                URL.revokeObjectURL(url);
                alert("OSM文件导出成功！");
            }

            generateOSMXML() {
                let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
                xml += '<osm version="0.6" generator="OSM Editor Enhanced 3D">\n';
                
                for (const [nodeId, nodeData] of this.nodes) {
                    xml += `  <node id="${nodeId}" lat="${nodeData.lat.toFixed(7)}" lon="${nodeData.lon.toFixed(7)}">\n`;
                    
                    const tags = nodeData.tags || {};
                    for (const [key, value] of Object.entries(tags)) {
                        if (key !== 'modified') {
                            xml += `    <tag k="${key}" v="${value}"/>\n`;
                        }
                    }
                    
                    xml += '  </node>\n';
                }
                
                for (const [wayId, wayData] of this.ways) {
                    xml += `  <way id="${wayId}">\n`;
                    
                    for (const nodeId of wayData.nodes) {
                        xml += `    <nd ref="${nodeId}"/>\n`;
                    }
                    
                    const tags = wayData.tags || {};
                    for (const [key, value] of Object.entries(tags)) {
                        xml += `    <tag k="${key}" v="${value}"/>\n`;
                    }
                    
                    xml += '  </way>\n';
                }
                
                xml += '</osm>';
                return xml;
            }

            clearData() {
                if (confirm("确定要清除所有数据吗？")) {
                    this.nodes.clear();
                    this.ways.clear();
                    this.relations.clear();
                    this.selectedNode = null;
                    this.selectedWay = null;
                    this.selectedWays.clear();
                    this.creatingWay = [];
                    this.measurePoints = [];
                    this.measureDistances = [];
                    this.undoStack = [];
                    this.redoStack = [];
                    this.updateUndoRedoButtons();
                    this.updateCreateStatus();
                    this.clearMeasurement();
                    this.redraw();
                    this.updateSelectionInfo();
                }
            }

            // 对话框工具方法
            createDialog(title, width, height) {
                this.closeDialog();
                
                const overlay = document.createElement('div');
                overlay.className = 'dialog-overlay';
                overlay.onclick = () => this.closeDialog();
                
                const dialog = document.createElement('div');
                dialog.className = 'dialog';
                dialog.style.width = width + 'px';
                dialog.style.height = height + 'px';
                
                document.body.appendChild(overlay);
                document.body.appendChild(dialog);
                
                this.currentDialog = { overlay, dialog };
                
                return dialog;
            }

            closeDialog() {
                if (this.currentDialog) {
                    this.currentDialog.overlay.remove();
                    this.currentDialog.dialog.remove();
                    this.currentDialog = null;
                }
            }
        }

        // 初始化编辑器
        let editor;
        window.addEventListener('load', () => {
            editor = new OSMEditor();
            window.editor = editor;
        });
    </script>
</body>
</html>